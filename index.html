<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>暗夜幸存者 - 生存射击游戏</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #0f0f1e 100%);
            color: #fff;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            touch-action: none;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #gameCanvas {
            border: 2px solid #FFD700;
            background: #1a1a2e;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.3);
            max-width: 100%;
            max-height: 100%;
            display: block;
        }

        /* UI层 */
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        /* 顶部状态栏 */
        #topBar {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            gap: 20px;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 10px;
            border: 2px solid #FFD700;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .stat-label {
            color: #FFD700;
            font-weight: bold;
        }

        .stat-value {
            color: #fff;
            font-size: 18px;
        }

        /* 血条 */
        #healthBar {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;
            height: 30px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #FFD700;
            border-radius: 15px;
            overflow: hidden;
        }

        #healthFill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ff6600);
            transition: width 0.3s ease;
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
        }

        #healthText {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        /* 经验条 */
        #expBar {
            position: absolute;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;
            height: 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #00ff00;
            border-radius: 10px;
            overflow: hidden;
        }

        #expFill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #00ff88);
            transition: width 0.3s ease;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }

        #expText {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 12px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        /* 菜单界面 */
        .menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 40px;
            border-radius: 20px;
            border: 3px solid #FFD700;
            text-align: center;
            pointer-events: auto;
            max-width: 90vw;
            max-height: 90vh;
            overflow-y: auto;
        }

        .menu h1 {
            color: #FFD700;
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        .menu h2 {
            color: #FFD700;
            font-size: 32px;
            margin-bottom: 20px;
        }

        .menu button {
            background: linear-gradient(135deg, #FFD700, #FFA500);
            color: #000;
            border: none;
            padding: 15px 40px;
            font-size: 20px;
            font-weight: bold;
            border-radius: 10px;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(255, 215, 0, 0.3);
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            min-height: 48px;
            min-width: 120px;
        }

        .menu button:hover,
        .menu button:active {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(255, 215, 0, 0.5);
        }

        /* 升级选择 */
        #upgradeMenu {
            display: none;
        }

        .upgrade-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }

        .upgrade-card {
            background: rgba(26, 26, 46, 0.8);
            border: 2px solid #FFD700;
            border-radius: 15px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            min-height: 80px;
        }

        .upgrade-card:hover,
        .upgrade-card:active {
            transform: scale(1.05);
            border-color: #00ff00;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
        }

        .upgrade-card h3 {
            color: #FFD700;
            margin-bottom: 10px;
        }

        .upgrade-card p {
            color: #ccc;
            font-size: 14px;
        }

        .upgrade-card .level {
            color: #00ff00;
            font-size: 12px;
            margin-top: 10px;
        }

        /* 商店 */
        #shopMenu {
            display: none;
        }

        .shop-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .shop-item {
            background: rgba(26, 26, 46, 0.8);
            border: 2px solid #FFD700;
            border-radius: 10px;
            padding: 15px;
            text-align: center;
        }

        .shop-item h4 {
            color: #FFD700;
            margin-bottom: 10px;
        }

        .shop-item .price {
            color: #FFD700;
            font-size: 18px;
            font-weight: bold;
            margin: 10px 0;
        }

        .shop-item button {
            background: linear-gradient(135deg, #00ff00, #00cc00);
            color: #000;
            border: none;
            padding: 8px 20px;
            font-size: 14px;
            font-weight: bold;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            min-height: 44px;
        }

        .shop-item button:disabled {
            background: #666;
            cursor: not-allowed;
        }

        .shop-item button:active:not(:disabled) {
            transform: scale(0.95);
        }

        .shop-item .current-level {
            color: #00ff00;
            font-size: 12px;
            margin-top: 5px;
        }

        /* 关卡选择 */
        #levelSelect {
            display: none;
        }

        .level-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .level-card {
            background: rgba(26, 26, 46, 0.8);
            border: 2px solid #FFD700;
            border-radius: 10px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            min-height: 100px;
        }

        .level-card:hover,
        .level-card:active {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        .level-card.locked {
            opacity: 0.5;
            cursor: not-allowed;
            border-color: #666;
        }

        .level-card h3 {
            color: #FFD700;
            margin-bottom: 10px;
        }

        .level-card .difficulty {
            color: #ff6600;
            font-size: 14px;
            margin-top: 5px;
        }

        /* 游戏结束 */
        #gameOverMenu {
            display: none;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 20px 0;
            text-align: left;
        }

        .stat-row {
            background: rgba(26, 26, 46, 0.5);
            padding: 10px;
            border-radius: 5px;
        }

        .stat-row span {
            color: #FFD700;
            font-weight: bold;
        }

        .hidden {
            display: none !important;
        }

        /* 波次提示 */
        #waveNotification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 64px;
            color: #FFD700;
            font-weight: bold;
            text-shadow: 0 0 30px rgba(255, 215, 0, 0.8);
            opacity: 0;
            transition: opacity 0.5s ease;
            pointer-events: none;
        }

        /* 伤害数字 */
        .damage-number {
            position: absolute;
            font-size: 20px;
            font-weight: bold;
            pointer-events: none;
            animation: floatUp 1s ease-out forwards;
        }

        @keyframes floatUp {
            0% {
                opacity: 1;
                transform: translateY(0);
            }
            100% {
                opacity: 0;
                transform: translateY(-50px);
            }
        }

        /* 移动端虚拟摇杆 */
        #mobileControls {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 200px;
            pointer-events: none;
            display: none;
        }

        #joystick {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 120px;
            height: 120px;
            pointer-events: auto;
        }

        #joystickBase {
            position: absolute;
            width: 120px;
            height: 120px;
            background: radial-gradient(circle, rgba(255, 215, 0, 0.3), rgba(255, 215, 0, 0.1));
            border: 3px solid rgba(255, 215, 0, 0.5);
            border-radius: 50%;
        }

        #joystickStick {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 50px;
            height: 50px;
            background: radial-gradient(circle, #FFD700, #FFA500);
            border: 3px solid #fff;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.1s ease;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
        }

        /* 移动端适配 */
        @media (max-width: 768px) {
            #mobileControls {
                display: block;
            }

            .menu {
                padding: 20px;
                max-width: 95vw;
            }

            .menu h1 {
                font-size: 32px;
            }

            .menu h2 {
                font-size: 24px;
            }

            .menu button {
                padding: 12px 30px;
                font-size: 18px;
                width: 100%;
                max-width: 300px;
            }

            #topBar {
                flex-wrap: wrap;
                gap: 5px;
                top: 10px;
                left: 10px;
                right: 10px;
            }

            .stat-box {
                padding: 5px 10px;
                font-size: 12px;
            }

            .stat-value {
                font-size: 14px;
            }

            #healthBar, #expBar {
                width: 90%;
            }

            .upgrade-grid, .shop-grid, .level-grid {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 480px) {
            .menu h1 {
                font-size: 24px;
            }

            .menu button {
                padding: 10px 20px;
                font-size: 16px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="1200" height="700"></canvas>
        
        <div id="ui">
            <!-- 顶部状态栏 -->
            <div id="topBar">
                <div class="stat-box">
                    <span class="stat-label">等级:</span>
                    <span class="stat-value" id="levelDisplay">1</span>
                </div>
                <div class="stat-box">
                    <span class="stat-label">💰 金币:</span>
                    <span class="stat-value" id="coinDisplay">0</span>
                </div>
                <div class="stat-box">
                    <span class="stat-label">⏱️ 时间:</span>
                    <span class="stat-value" id="timeDisplay">0:00</span>
                </div>
                <div class="stat-box">
                    <span class="stat-label">💀 击杀:</span>
                    <span class="stat-value" id="killDisplay">0</span>
                </div>
            </div>

            <!-- 血条 -->
            <div id="healthBar">
                <div id="healthFill" style="width: 100%;"></div>
                <div id="healthText">100 / 100</div>
            </div>

            <!-- 经验条 -->
            <div id="expBar">
                <div id="expFill" style="width: 0%;"></div>
                <div id="expText">0 / 100</div>
            </div>

            <!-- 波次提示 -->
            <div id="waveNotification"></div>

            <!-- 移动端虚拟摇杆 -->
            <div id="mobileControls">
                <div id="joystick">
                    <div id="joystickBase"></div>
                    <div id="joystickStick"></div>
                </div>
            </div>

            <!-- 主菜单 -->
            <div id="mainMenu" class="menu">
                <h1>🧛 暗夜幸存者 🧛</h1>
                <p style="margin-bottom: 30px;">在无尽的黑暗中生存，升级你的角色，解锁强大的武器和技能！</p>
                <button id="startGameBtn">开始游戏</button>
                <button id="shopBtn">永久升级商店</button>
                <div style="margin-top: 30px;">
                    <h3 style="color: #FFD700;">游戏说明</h3>
                    <p id="gameInstructions" style="font-size: 14px; color: #ccc; margin-top: 10px; text-align: left;">
                        🎮 使用 WASD 或方向键移动<br>
                        🗡️ 自动攻击附近的敌人<br>
                        ⬆️ 击败敌人获得经验升级，选择强大的技能<br>
                        💰 收集金币进行永久升级<br>
                        🎯 每个关卡都有独特的挑战和Boss<br>
                        🏆 活得越久，奖励越丰厚！
                    </p>
                </div>
            </div>

            <!-- 关卡选择 -->
            <div id="levelSelect" class="menu">
                <h2>选择关卡</h2>
                <div class="level-grid" id="levelGrid"></div>
                <button id="levelBackBtn">返回</button>
            </div>

            <!-- 升级菜单 -->
            <div id="upgradeMenu" class="menu">
                <h2>选择升级</h2>
                <p>选择一个升级来增强你的能力！</p>
                <div class="upgrade-grid" id="upgradeGrid"></div>
            </div>

            <!-- 商店菜单 -->
            <div id="shopMenu" class="menu">
                <h2>永久升级商店</h2>
                <p>💰 你的金币: <span id="shopCoins">0</span></p>
                <div class="shop-grid" id="shopGrid"></div>
                <button id="shopBackBtn">返回</button>
            </div>

            <!-- 游戏结束 -->
            <div id="gameOverMenu" class="menu">
                <h1 id="gameOverTitle">游戏结束</h1>
                <div class="stats-grid" id="gameStats"></div>
                <div style="margin-top: 20px;">
                    <button id="restartBtn">重新开始</button>
                    <button id="gameOverBackBtn">返回主菜单</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 游戏主类
        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.width = this.canvas.width;
                this.height = this.canvas.height;
                
                // 游戏状态
                this.state = 'menu'; // menu, playing, paused, upgrading, gameOver
                this.currentLevel = null;
                
                // 玩家数据
                this.player = null;
                this.enemies = [];
                this.projectiles = [];
                this.particles = [];
                this.pickups = [];
                
                // 游戏数据
                this.kills = 0;
                this.totalCoins = parseInt(localStorage.getItem('totalCoins') || '0');
                this.gameTime = 0;
                this.wave = 0;
                this.waveTimer = 0;
                this.damageNumbers = [];
                
                // 永久升级
                this.permanentUpgrades = JSON.parse(localStorage.getItem('permanentUpgrades') || '{}');
                
                // 输入
                this.keys = {};
                this.touchInput = { x: 0, y: 0, active: false };
                this.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                
                // 关卡定义
                this.levels = [
                    {
                        id: 1,
                        name: '暗夜森林',
                        difficulty: '简单',
                        enemySpawnRate: 2,
                        enemyHealthMultiplier: 1,
                        duration: 300, // 5分钟
                        unlocked: true
                    },
                    {
                        id: 2,
                        name: '被诅咒的墓地',
                        difficulty: '中等',
                        enemySpawnRate: 3,
                        enemyHealthMultiplier: 1.5,
                        duration: 420,
                        unlocked: false
                    },
                    {
                        id: 3,
                        name: '恶魔城堡',
                        difficulty: '困难',
                        enemySpawnRate: 4,
                        enemyHealthMultiplier: 2,
                        duration: 600,
                        unlocked: false
                    },
                    {
                        id: 4,
                        name: '地狱之门',
                        difficulty: '噩梦',
                        enemySpawnRate: 5,
                        enemyHealthMultiplier: 3,
                        duration: 900,
                        unlocked: false
                    }
                ];
                
                this.setupEventListeners();
                this.setupButtonListeners();
                this.updateShopDisplay();
                this.resizeCanvas();
                
                // 更新移动端说明
                if (this.isMobile) {
                    const instructions = document.getElementById('gameInstructions');
                    if (instructions) {
                        instructions.innerHTML = `
                            🎮 使用屏幕左下角的虚拟摇杆移动<br>
                            🗡️ 自动攻击附近的敌人<br>
                            ⬆️ 击败敌人获得经验升级，选择强大的技能<br>
                            💰 收集金币进行永久升级<br>
                            🎯 每个关卡都有独特的挑战和Boss<br>
                            🏆 活得越久，奖励越丰厚！
                        `;
                    }
                }
            }
            
            resizeCanvas() {
                const container = document.getElementById('gameContainer');
                const containerWidth = container.clientWidth;
                const containerHeight = container.clientHeight;
                
                const gameAspect = 1200 / 700;
                const containerAspect = containerWidth / containerHeight;
                
                if (containerAspect > gameAspect) {
                    this.canvas.style.height = containerHeight + 'px';
                    this.canvas.style.width = (containerHeight * gameAspect) + 'px';
                } else {
                    this.canvas.style.width = containerWidth + 'px';
                    this.canvas.style.height = (containerWidth / gameAspect) + 'px';
                }
            }
            
            setupEventListeners() {
                // 键盘事件
                document.addEventListener('keydown', (e) => {
                    this.keys[e.key] = true;
                    if (e.key === 'Escape' && this.state === 'playing') {
                        this.pauseGame();
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.key] = false;
                });

                // 窗口大小调整
                window.addEventListener('resize', () => this.resizeCanvas());

                // 移动端虚拟摇杆
                if (this.isMobile) {
                    this.setupJoystick();
                }
            }

            setupJoystick() {
                const joystick = document.getElementById('joystick');
                const joystickStick = document.getElementById('joystickStick');
                const joystickBase = document.getElementById('joystickBase');
                
                let touchId = null;
                const maxDistance = 35;
                
                const handleTouchStart = (e) => {
                    if (this.state !== 'playing') return;
                    e.preventDefault();
                    const touch = e.touches[0];
                    touchId = touch.identifier;
                };
                
                const handleTouchMove = (e) => {
                    if (this.state !== 'playing' || touchId === null) return;
                    e.preventDefault();
                    
                    const touch = Array.from(e.touches).find(t => t.identifier === touchId);
                    if (!touch) return;
                    
                    const rect = joystickBase.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    
                    let dx = touch.clientX - centerX;
                    let dy = touch.clientY - centerY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > maxDistance) {
                        dx = (dx / distance) * maxDistance;
                        dy = (dy / distance) * maxDistance;
                    }
                    
                    joystickStick.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
                    
                    // 设置触摸输入
                    this.touchInput.x = dx / maxDistance;
                    this.touchInput.y = dy / maxDistance;
                    this.touchInput.active = true;
                };
                
                const handleTouchEnd = (e) => {
                    if (touchId === null) return;
                    e.preventDefault();
                    
                    const touches = Array.from(e.changedTouches);
                    if (touches.some(t => t.identifier === touchId)) {
                        touchId = null;
                        joystickStick.style.transform = 'translate(-50%, -50%)';
                        this.touchInput.x = 0;
                        this.touchInput.y = 0;
                        this.touchInput.active = false;
                    }
                };
                
                joystick.addEventListener('touchstart', handleTouchStart, { passive: false });
                joystick.addEventListener('touchmove', handleTouchMove, { passive: false });
                joystick.addEventListener('touchend', handleTouchEnd, { passive: false });
                joystick.addEventListener('touchcancel', handleTouchEnd, { passive: false });
            }

            setupButtonListeners() {
                // 主菜单按钮
                const startGameBtn = document.getElementById('startGameBtn');
                const shopBtn = document.getElementById('shopBtn');
                
                if (startGameBtn) {
                    startGameBtn.addEventListener('click', () => this.showLevelSelect());
                    startGameBtn.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        this.showLevelSelect();
                    });
                }
                
                if (shopBtn) {
                    shopBtn.addEventListener('click', () => this.showShop());
                    shopBtn.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        this.showShop();
                    });
                }
                
                // 返回按钮
                const levelBackBtn = document.getElementById('levelBackBtn');
                const shopBackBtn = document.getElementById('shopBackBtn');
                const gameOverBackBtn = document.getElementById('gameOverBackBtn');
                const restartBtn = document.getElementById('restartBtn');
                
                if (levelBackBtn) {
                    levelBackBtn.addEventListener('click', () => this.showMainMenu());
                    levelBackBtn.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        this.showMainMenu();
                    });
                }
                
                if (shopBackBtn) {
                    shopBackBtn.addEventListener('click', () => this.hideShop());
                    shopBackBtn.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        this.hideShop();
                    });
                }
                
                if (gameOverBackBtn) {
                    gameOverBackBtn.addEventListener('click', () => this.showMainMenu());
                    gameOverBackBtn.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        this.showMainMenu();
                    });
                }
                
                if (restartBtn) {
                    restartBtn.addEventListener('click', () => this.restart());
                    restartBtn.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        this.restart();
                    });
                }
            }
            
            showMainMenu() {
                this.state = 'menu';
                document.getElementById('mainMenu').classList.remove('hidden');
                document.getElementById('levelSelect').classList.add('hidden');
                document.getElementById('upgradeMenu').classList.add('hidden');
                document.getElementById('shopMenu').classList.add('hidden');
                document.getElementById('gameOverMenu').classList.add('hidden');
            }
            
            showLevelSelect() {
                this.state = 'levelSelect';
                document.getElementById('mainMenu').classList.add('hidden');
                document.getElementById('levelSelect').classList.remove('hidden');
                
                const grid = document.getElementById('levelGrid');
                grid.innerHTML = '';
                
                this.levels.forEach(level => {
                    const card = document.createElement('div');
                    card.className = 'level-card' + (level.unlocked ? '' : ' locked');
                    card.innerHTML = `
                        <h3>${level.name}</h3>
                        <p>关卡 ${level.id}</p>
                        <p class="difficulty">难度: ${level.difficulty}</p>
                        <p style="font-size: 12px; color: #ccc; margin-top: 10px;">
                            持续时间: ${Math.floor(level.duration / 60)}:${(level.duration % 60).toString().padStart(2, '0')}
                        </p>
                    `;
                    
                    if (level.unlocked) {
                        const startLevel = () => this.startLevel(level);
                        card.onclick = startLevel;
                        card.addEventListener('touchend', (e) => {
                            e.preventDefault();
                            startLevel();
                        });
                        card.style.cursor = 'pointer';
                    }
                    
                    grid.appendChild(card);
                });
            }
            
            startLevel(level) {
                this.currentLevel = level;
                this.state = 'playing';
                this.gameTime = 0;
                this.kills = 0;
                this.wave = 0;
                this.waveTimer = 0;
                
                // 隐藏所有菜单
                document.getElementById('mainMenu').classList.add('hidden');
                document.getElementById('levelSelect').classList.add('hidden');
                document.getElementById('upgradeMenu').classList.add('hidden');
                document.getElementById('shopMenu').classList.add('hidden');
                document.getElementById('gameOverMenu').classList.add('hidden');
                
                // 初始化玩家
                this.player = new Player(this.width / 2, this.height / 2);
                this.enemies = [];
                this.projectiles = [];
                this.particles = [];
                this.pickups = [];
                this.damageNumbers = [];
                
                console.log('玩家创建完成:', this.player);
                console.log('游戏状态:', this.state);
                console.log('画布尺寸:', this.width, 'x', this.height);
                
                // 立即添加一个测试敌人
                this.enemies.push(new Enemy(this.width / 2 + 100, this.height / 2, 'zombie', 1));
                console.log('添加测试敌人，总敌人数:', this.enemies.length);
                
                // 开始游戏循环
                this.lastTime = performance.now();
                this.gameLoop();
            }
            
            gameLoop(currentTime = performance.now()) {
                if (this.state !== 'playing') {
                    console.log('游戏循环停止，状态:', this.state);
                    return;
                }
                
                const deltaTime = (currentTime - this.lastTime) / 1000;
                this.lastTime = currentTime;
                
                this.update(deltaTime);
                this.render();
                
                requestAnimationFrame((time) => this.gameLoop(time));
            }
            
            update(deltaTime) {
                // 更新游戏时间
                this.gameTime += deltaTime;
                
                // 检查是否通关
                if (this.gameTime >= this.currentLevel.duration) {
                    this.levelComplete();
                    return;
                }
                
                // 更新波次
                this.waveTimer += deltaTime;
                if (this.waveTimer >= 30) { // 每30秒一波
                    this.waveTimer = 0;
                    this.wave++;
                    this.showWaveNotification(this.wave);
                }
                
                // 更新玩家
                this.player.update(deltaTime, this.keys, this);
                
                // 生成敌人
                this.spawnEnemies(deltaTime);
                
                
                // 更新敌人
                this.enemies = this.enemies.filter(enemy => {
                    enemy.update(deltaTime, this.player);
                    
                    // 检查与玩家碰撞
                    const dx = enemy.x - this.player.x;
                    const dy = enemy.y - this.player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < enemy.radius + this.player.radius) {
                        this.player.takeDamage(enemy.damage);
                        enemy.health = 0;
                    }
                    
                    if (enemy.health <= 0) {
                        this.enemyKilled(enemy);
                        return false;
                    }
                    return true;
                });
                
                // 更新弹药
                this.projectiles = this.projectiles.filter(proj => {
                    proj.update(deltaTime);
                    
                    let hitEnemy = false;
                    
                    // 检查与敌人碰撞
                    for (let enemy of this.enemies) {
                        const dx = proj.x - enemy.x;
                        const dy = proj.y - enemy.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < enemy.radius + proj.radius) {
                            const actualDamage = proj.damage;
                            enemy.takeDamage(actualDamage);
                            
                            // 显示伤害数字
                            this.damageNumbers.push(new DamageNumber(proj.x, proj.y, Math.floor(actualDamage)));
                            
                            // 生命偷取
                            if (this.player.skills.lifeSteal > 0) {
                                const healAmount = actualDamage * 0.05 * this.player.skills.lifeSteal;
                                this.player.heal(healAmount);
                            }
                            
                            this.createHitEffect(proj.x, proj.y, proj.color);
                            
                            // 检查穿透
                            if (proj.canPierce()) {
                                proj.onPierce();
                                hitEnemy = true;
                                break; // 只击中一个敌人后继续
                            } else {
                                return false; // 没有穿透，弹药消失
                            }
                        }
                    }
                    
                    // 检查是否超出范围
                    return proj.lifetime > 0;
                });
                
                // 更新粒子
                this.particles = this.particles.filter(p => {
                    p.update(deltaTime);
                    return p.lifetime > 0;
                });
                
                // 更新伤害数字
                this.damageNumbers = this.damageNumbers.filter(d => {
                    d.update(deltaTime);
                    return d.lifetime > 0;
                });
                
                // 更新掉落物
                this.pickups = this.pickups.filter(pickup => {
                    pickup.update(deltaTime, this.player);
                    
                    const dx = pickup.x - this.player.x;
                    const dy = pickup.y - this.player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < 30) {
                        if (pickup.type === 'exp') {
                            this.player.addExp(pickup.value);
                        } else if (pickup.type === 'coin') {
                            this.player.coins += pickup.value;
                        } else if (pickup.type === 'health') {
                            this.player.heal(pickup.value);
                        }
                        return false;
                    }
                    
                    return pickup.lifetime > 0;
                });
                
                // 更新UI
                this.updateUI();
                
                // 检查玩家是否死亡
                if (this.player.health <= 0) {
                    this.gameOver(false);
                }
            }
            
            render() {
                // 清空画布
                this.ctx.fillStyle = '#1a1a2e';
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                // 绘制网格背景
                this.ctx.strokeStyle = 'rgba(255, 215, 0, 0.1)';
                this.ctx.lineWidth = 1;
                for (let x = 0; x < this.width; x += 50) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.height);
                    this.ctx.stroke();
                }
                for (let y = 0; y < this.height; y += 50) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.width, y);
                    this.ctx.stroke();
                }
                
                // 绘制掉落物
                this.pickups.forEach(p => p.render(this.ctx));
                
                // 绘制粒子
                this.particles.forEach(p => p.render(this.ctx));
                
                // 绘制伤害数字
                this.damageNumbers.forEach(d => d.render(this.ctx));
                
                // 绘制弹药
                this.projectiles.forEach(p => p.render(this.ctx));
                
                // 绘制敌人
                // 绘制敌人
                console.log('渲染敌人数量:', this.enemies.length);
                this.enemies.forEach(e => e.render(this.ctx));
                
                // 绘制玩家
                if (this.player) {
                    console.log('渲染玩家位置:', this.player.x, this.player.y);
                    this.player.render(this.ctx);
                } else {
                    console.log('玩家不存在，无法渲染');
                }
                
            }
            
            spawnEnemies(deltaTime) {
                const spawnRate = this.currentLevel.enemySpawnRate * (1 + this.wave * 0.1);
                const spawnChance = spawnRate * deltaTime;
                
                if (Math.random() < spawnChance) {
                    // 在屏幕外生成
                    const side = Math.floor(Math.random() * 4);
                    let x, y;
                    
                    switch(side) {
                        case 0: // 上
                            x = Math.random() * this.width;
                            y = -30;
                            break;
                        case 1: // 右
                            x = this.width + 30;
                            y = Math.random() * this.height;
                            break;
                        case 2: // 下
                            x = Math.random() * this.width;
                            y = this.height + 30;
                            break;
                        case 3: // 左
                            x = -30;
                            y = Math.random() * this.height;
                            break;
                    }
                    
                    // 随机敌人类型，波次越高，高级敌人几率越大
                    let type;
                    const roll = Math.random();
                    
                    if (this.wave >= 10 && roll < 0.05) {
                        type = 'boss';
                    } else if (this.wave >= 5 && roll < 0.15) {
                        type = 'elite';
                    } else if (roll < 0.5) {
                        type = 'zombie';
                    } else if (roll < 0.8) {
                        type = 'ghost';
                    } else {
                        type = 'demon';
                    }
                    
                    this.enemies.push(new Enemy(x, y, type, this.currentLevel.enemyHealthMultiplier * (1 + this.wave * 0.2)));
                }
                
                // Boss 生成（每5波）
                if (this.wave > 0 && this.wave % 5 === 0 && this.waveTimer < 1) {
                    const bossExists = this.enemies.some(e => e.type === 'boss');
                    if (!bossExists) {
                        const x = this.width / 2;
                        const y = -50;
                        this.enemies.push(new Enemy(x, y, 'boss', this.currentLevel.enemyHealthMultiplier * (1 + this.wave * 0.3)));
                        this.showWaveNotification(`Boss 出现！`);
                    }
                }
            }
            
            enemyKilled(enemy) {
                this.kills++;
                this.player.coins += enemy.coinValue;
                
                // 创建掉落物
                if (Math.random() < 0.8) {
                    this.pickups.push(new Pickup(enemy.x, enemy.y, 'exp', enemy.expValue));
                }
                if (Math.random() < 0.3) {
                    this.pickups.push(new Pickup(enemy.x, enemy.y, 'coin', enemy.coinValue * 2));
                }
                if (Math.random() < 0.1 && this.player.health < this.player.maxHealth) {
                    this.pickups.push(new Pickup(enemy.x, enemy.y, 'health', 20));
                }
                
                // 创建死亡粒子
                const particleCount = enemy.isBoss ? 50 : enemy.isElite ? 30 : 10;
                for (let i = 0; i < particleCount; i++) {
                    this.particles.push(new Particle(enemy.x, enemy.y, enemy.color));
                }
                
                // Boss 击杀特效
                if (enemy.isBoss) {
                    this.showWaveNotification('Boss 击败！');
                }
            }
            
            createHitEffect(x, y, color = '#ffff00') {
                for (let i = 0; i < 5; i++) {
                    this.particles.push(new Particle(x, y, color));
                }
            }
            
            showUpgradeMenu() {
                this.state = 'upgrading';
                document.getElementById('upgradeMenu').classList.remove('hidden');
                
                const grid = document.getElementById('upgradeGrid');
                grid.innerHTML = '';
                
                // 生成3个随机升级选项
                const availableUpgrades = this.player.getAvailableUpgrades();
                const shuffled = availableUpgrades.sort(() => Math.random() - 0.5);
                const options = shuffled.slice(0, 3);
                
                options.forEach(upgrade => {
                    const card = document.createElement('div');
                    card.className = 'upgrade-card';
                    card.innerHTML = `
                        <h3>${upgrade.name}</h3>
                        <p>${upgrade.description}</p>
                        <p class="level">等级 ${upgrade.currentLevel} → ${upgrade.currentLevel + 1}</p>
                    `;
                    const applyUpgrade = () => {
                        this.player.applyUpgrade(upgrade);
                        document.getElementById('upgradeMenu').classList.add('hidden');
                        this.state = 'playing';
                        this.lastTime = performance.now();
                        this.gameLoop();
                    };
                    
                    card.onclick = applyUpgrade;
                    card.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        applyUpgrade();
                    });
                    
                    grid.appendChild(card);
                });
            }
            
            showShop() {
                document.getElementById('mainMenu').classList.add('hidden');
                document.getElementById('shopMenu').classList.remove('hidden');
                this.updateShopDisplay();
            }
            
            hideShop() {
                document.getElementById('shopMenu').classList.add('hidden');
                document.getElementById('mainMenu').classList.remove('hidden');
            }
            
            updateShopDisplay() {
                document.getElementById('shopCoins').textContent = this.totalCoins;
                document.getElementById('coinDisplay').textContent = this.totalCoins;
                
                const grid = document.getElementById('shopGrid');
                grid.innerHTML = '';
                
                const shopItems = [
                    { id: 'maxHealth', name: '最大生命值', basePrice: 50, increment: 20 },
                    { id: 'damage', name: '伤害加成', basePrice: 100, increment: 0.1 },
                    { id: 'moveSpeed', name: '移动速度', basePrice: 75, increment: 5 },
                    { id: 'attackSpeed', name: '攻击速度', basePrice: 100, increment: 0.1 },
                    { id: 'expMultiplier', name: '经验加成', basePrice: 150, increment: 0.1 },
                    { id: 'coinMultiplier', name: '金币加成', basePrice: 150, increment: 0.1 }
                ];
                
                shopItems.forEach(item => {
                    const level = this.permanentUpgrades[item.id] || 0;
                    const price = Math.floor(item.basePrice * Math.pow(1.5, level));
                    
                    const div = document.createElement('div');
                    div.className = 'shop-item';
                    div.innerHTML = `
                        <h4>${item.name}</h4>
                        <p class="current-level">等级: ${level}</p>
                        <p class="price">${price} 💰</p>
                        <button ${this.totalCoins < price ? 'disabled' : ''} data-item-id="${item.id}" data-price="${price}" class="shop-buy-btn">
                            购买
                        </button>
                    `;
                    
                    const buyBtn = div.querySelector('.shop-buy-btn');
                    if (buyBtn && !buyBtn.disabled) {
                        const buyUpgrade = () => this.buyUpgrade(item.id, price);
                        buyBtn.addEventListener('click', buyUpgrade);
                        buyBtn.addEventListener('touchend', (e) => {
                            e.preventDefault();
                            buyUpgrade();
                        });
                    }
                    
                    grid.appendChild(div);
                });
            }
            
            buyUpgrade(id, price) {
                if (this.totalCoins >= price) {
                    this.totalCoins -= price;
                    this.permanentUpgrades[id] = (this.permanentUpgrades[id] || 0) + 1;
                    localStorage.setItem('totalCoins', this.totalCoins.toString());
                    localStorage.setItem('permanentUpgrades', JSON.stringify(this.permanentUpgrades));
                    this.updateShopDisplay();
                }
            }
            
            updateUI() {
                document.getElementById('levelDisplay').textContent = this.player.level;
                document.getElementById('coinDisplay').textContent = this.player.coins;
                document.getElementById('killDisplay').textContent = this.kills;
                
                const minutes = Math.floor(this.gameTime / 60);
                const seconds = Math.floor(this.gameTime % 60);
                document.getElementById('timeDisplay').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                
                const healthPercent = (this.player.health / this.player.maxHealth) * 100;
                document.getElementById('healthFill').style.width = healthPercent + '%';
                document.getElementById('healthText').textContent = `${Math.ceil(this.player.health)} / ${this.player.maxHealth}`;
                
                const expPercent = (this.player.exp / this.player.expToNextLevel) * 100;
                document.getElementById('expFill').style.width = expPercent + '%';
                document.getElementById('expText').textContent = `${Math.floor(this.player.exp)} / ${this.player.expToNextLevel}`;
            }
            
            showWaveNotification(wave) {
                const notification = document.getElementById('waveNotification');
                notification.textContent = `第 ${wave} 波！`;
                notification.style.opacity = '1';
                
                setTimeout(() => {
                    notification.style.opacity = '0';
                }, 2000);
            }
            
            levelComplete() {
                this.gameOver(true);
            }
            
            gameOver(victory) {
                this.state = 'gameOver';
                
                // 保存金币
                this.totalCoins += this.player.coins;
                localStorage.setItem('totalCoins', this.totalCoins.toString());
                
                // 解锁下一关
                if (victory && this.currentLevel.id < this.levels.length) {
                    this.levels[this.currentLevel.id].unlocked = true;
                }
                
                // 显示游戏结束界面
                document.getElementById('gameOverTitle').textContent = victory ? '🎉 关卡完成！🎉' : '💀 游戏结束 💀';
                
                const statsGrid = document.getElementById('gameStats');
                const minutes = Math.floor(this.gameTime / 60);
                const seconds = Math.floor(this.gameTime % 60);
                
                statsGrid.innerHTML = `
                    <div class="stat-row"><span>存活时间:</span> ${minutes}:${seconds.toString().padStart(2, '0')}</div>
                    <div class="stat-row"><span>击杀数:</span> ${this.kills}</div>
                    <div class="stat-row"><span>等级:</span> ${this.player.level}</div>
                    <div class="stat-row"><span>金币:</span> ${this.player.coins}</div>
                `;
                
                document.getElementById('gameOverMenu').classList.remove('hidden');
            }
            
            restart() {
                document.getElementById('gameOverMenu').classList.add('hidden');
                if (this.currentLevel) {
                    this.startLevel(this.currentLevel);
                }
            }
            
            pauseGame() {
                // 暂停功能
                this.state = 'paused';
            }
        }

        // 玩家类
        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 20;
                this.color = '#FFD700';
                
                // 属性
                this.maxHealth = 100 + (game.permanentUpgrades.maxHealth || 0) * 20;
                this.health = this.maxHealth;
                this.moveSpeed = 200 + (game.permanentUpgrades.moveSpeed || 0) * 5;
                this.damage = 10 + (game.permanentUpgrades.damage || 0) * 0.1;
                this.attackSpeed = 1 + (game.permanentUpgrades.attackSpeed || 0) * 0.1;
                
                // 经验和等级
                this.level = 1;
                this.exp = 0;
                this.expToNextLevel = 100;
                this.expMultiplier = 1 + (game.permanentUpgrades.expMultiplier || 0) * 0.1;
                
                // 金币
                this.coins = 0;
                this.coinMultiplier = 1 + (game.permanentUpgrades.coinMultiplier || 0) * 0.1;
                
                // 武器
                this.weapons = [
                    { 
                        type: 'sword', 
                        level: 1, 
                        cooldown: 0, 
                        maxCooldown: 1 / this.attackSpeed,
                        projectileCount: 1,
                        range: 300
                    }
                ];
                
                // 技能
                this.skills = {
                    multishot: 0,
                    pierce: 0,
                    projectileSize: 0,
                    critChance: 0,
                    lifeSteal: 0,
                    aura: 0
                };
                
                // 光环效果
                this.auraTimer = 0;
            }
            
            update(deltaTime, keys, game) {
                // 移动
                let dx = 0, dy = 0;
                
                // 键盘输入
                if (keys['w'] || keys['W'] || keys['ArrowUp']) dy -= 1;
                if (keys['s'] || keys['S'] || keys['ArrowDown']) dy += 1;
                if (keys['a'] || keys['A'] || keys['ArrowLeft']) dx -= 1;
                if (keys['d'] || keys['D'] || keys['ArrowRight']) dx += 1;
                
                // 触摸输入（移动端摇杆）
                if (game.touchInput.active) {
                    dx = game.touchInput.x;
                    dy = game.touchInput.y;
                } else if (dx !== 0 && dy !== 0) {
                    // 归一化对角线移动（仅键盘）
                    dx *= 0.707;
                    dy *= 0.707;
                }
                
                this.x += dx * this.moveSpeed * deltaTime;
                this.y += dy * this.moveSpeed * deltaTime;
                
                // 限制在边界内
                this.x = Math.max(this.radius, Math.min(game.width - this.radius, this.x));
                this.y = Math.max(this.radius, Math.min(game.height - this.radius, this.y));
                
                // 更新武器
                this.weapons.forEach(weapon => {
                    weapon.cooldown -= deltaTime;
                    if (weapon.cooldown <= 0) {
                        this.attack(weapon, game);
                        weapon.cooldown = weapon.maxCooldown;
                    }
                });
                
                // 更新光环效果
                if (this.skills.aura > 0) {
                    this.auraTimer -= deltaTime;
                    if (this.auraTimer <= 0) {
                        this.auraTimer = 0.5; // 每0.5秒触发一次
                        
                        game.enemies.forEach(enemy => {
                            const dx = enemy.x - this.x;
                            const dy = enemy.y - this.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            
                            if (dist < 150 * this.skills.aura) {
                                enemy.takeDamage(this.damage * 0.5 * this.skills.aura);
                            }
                        });
                    }
                }
            }
            
            attack(weapon, game) {
                // 找到最近的敌人
                let nearest = null;
                let minDist = weapon.range || 300;
                
                game.enemies.forEach(enemy => {
                    const dx = enemy.x - this.x;
                    const dy = enemy.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < minDist) {
                        minDist = dist;
                        nearest = enemy;
                    }
                });
                
                if (nearest) {
                    const baseAngle = Math.atan2(nearest.y - this.y, nearest.x - this.x);
                    const projectileCount = weapon.projectileCount + this.skills.multishot;
                    
                    // 计算伤害
                    let finalDamage = this.damage * weapon.level;
                    
                    // 暴击判断
                    if (Math.random() < this.skills.critChance * 0.1) {
                        finalDamage *= 2;
                    }
                    
                    // 发射多个弹药
                    for (let i = 0; i < projectileCount; i++) {
                        let angle = baseAngle;
                        
                        if (projectileCount > 1) {
                            const spread = Math.PI / 6; // 30度扩散
                            angle += (i - (projectileCount - 1) / 2) * (spread / projectileCount);
                        }
                        
                        const size = 5 * (1 + this.skills.projectileSize * 0.3);
                        const pierce = this.skills.pierce;
                        
                        if (weapon.type === 'sword') {
                            game.projectiles.push(new Projectile(
                                this.x, this.y, angle, 
                                finalDamage, 
                                400, '#FFD700', size, pierce
                            ));
                        } else if (weapon.type === 'fireball') {
                            game.projectiles.push(new Projectile(
                                this.x, this.y, angle, 
                                finalDamage * 1.5, 
                                300, '#ff6600', size * 1.5, pierce, 'fireball'
                            ));
                        } else if (weapon.type === 'lightning') {
                            game.projectiles.push(new Projectile(
                                this.x, this.y, angle, 
                                finalDamage * 0.8, 
                                600, '#00ffff', size * 0.8, pierce + 2, 'lightning'
                            ));
                        } else if (weapon.type === 'holy') {
                            game.projectiles.push(new Projectile(
                                this.x, this.y, angle, 
                                finalDamage * 2, 
                                250, '#ffffff', size * 2, pierce, 'holy'
                            ));
                        }
                    }
                }
            }
            
            takeDamage(amount) {
                this.health -= amount;
                if (this.health < 0) this.health = 0;
            }
            
            heal(amount) {
                this.health = Math.min(this.maxHealth, this.health + amount);
            }
            
            addExp(amount) {
                this.exp += amount * this.expMultiplier;
                
                while (this.exp >= this.expToNextLevel) {
                    this.levelUp();
                }
            }
            
            levelUp() {
                this.exp -= this.expToNextLevel;
                this.level++;
                this.expToNextLevel = Math.floor(100 * Math.pow(1.2, this.level - 1));
                
                // 显示升级菜单
                game.showUpgradeMenu();
            }
            
            getAvailableUpgrades() {
                const upgrades = [
                    {
                        id: 'maxHealth',
                        name: '💗 生命强化',
                        description: '最大生命值 +20',
                        currentLevel: 0,
                        apply: () => {
                            this.maxHealth += 20;
                            this.health += 20;
                        }
                    },
                    {
                        id: 'damage',
                        name: '⚔️ 伤害提升',
                        description: '伤害 +20%',
                        currentLevel: 0,
                        apply: () => {
                            this.damage *= 1.2;
                        }
                    },
                    {
                        id: 'attackSpeed',
                        name: '⚡ 攻击速度',
                        description: '攻击速度 +15%',
                        currentLevel: 0,
                        apply: () => {
                            this.attackSpeed *= 1.15;
                            this.weapons.forEach(w => w.maxCooldown /= 1.15);
                        }
                    },
                    {
                        id: 'moveSpeed',
                        name: '🏃 移动速度',
                        description: '移动速度 +10%',
                        currentLevel: 0,
                        apply: () => {
                            this.moveSpeed *= 1.1;
                        }
                    },
                    {
                        id: 'multishot',
                        name: '🎯 多重射击',
                        description: '发射 +1 个额外弹药',
                        currentLevel: this.skills.multishot,
                        apply: () => {
                            this.skills.multishot++;
                        }
                    },
                    {
                        id: 'projectileSize',
                        name: '📏 弹药增大',
                        description: '弹药体积和范围 +30%',
                        currentLevel: this.skills.projectileSize,
                        apply: () => {
                            this.skills.projectileSize++;
                        }
                    },
                    {
                        id: 'pierce',
                        name: '🎯 穿透',
                        description: '弹药可以穿透 +1 个敌人',
                        currentLevel: this.skills.pierce,
                        apply: () => {
                            this.skills.pierce++;
                        }
                    },
                    {
                        id: 'critChance',
                        name: '💥 暴击',
                        description: '暴击几率 +10% (造成2倍伤害)',
                        currentLevel: this.skills.critChance,
                        apply: () => {
                            this.skills.critChance++;
                        }
                    },
                    {
                        id: 'lifeSteal',
                        name: '🩸 生命偷取',
                        description: '造成伤害时恢复 +5% 生命',
                        currentLevel: this.skills.lifeSteal,
                        apply: () => {
                            this.skills.lifeSteal++;
                        }
                    },
                    {
                        id: 'aura',
                        name: '🌟 神圣光环',
                        description: '周围敌人持续受到伤害，范围增加',
                        currentLevel: this.skills.aura,
                        apply: () => {
                            this.skills.aura++;
                        }
                    }
                ];
                
                // 添加新武器升级
                const weaponUpgrades = [
                    {
                        id: 'fireball',
                        name: '🔥 火球术',
                        description: '获得火球武器，造成高额伤害',
                        currentLevel: 0,
                        isWeapon: true,
                        apply: () => {
                            const existing = this.weapons.find(w => w.type === 'fireball');
                            if (existing) {
                                existing.level++;
                                existing.projectileCount++;
                            } else {
                                this.weapons.push({
                                    type: 'fireball',
                                    level: 1,
                                    cooldown: 0,
                                    maxCooldown: 1.5,
                                    projectileCount: 1,
                                    range: 350
                                });
                            }
                        }
                    },
                    {
                        id: 'lightning',
                        name: '⚡ 闪电链',
                        description: '获得闪电武器，攻击速度快，自带穿透',
                        currentLevel: 0,
                        isWeapon: true,
                        apply: () => {
                            const existing = this.weapons.find(w => w.type === 'lightning');
                            if (existing) {
                                existing.level++;
                                existing.maxCooldown *= 0.9;
                            } else {
                                this.weapons.push({
                                    type: 'lightning',
                                    level: 1,
                                    cooldown: 0,
                                    maxCooldown: 0.5,
                                    projectileCount: 1,
                                    range: 400
                                });
                            }
                        }
                    },
                    {
                        id: 'holy',
                        name: '✨ 神圣之光',
                        description: '获得神圣武器，伤害极高但攻击较慢',
                        currentLevel: 0,
                        isWeapon: true,
                        apply: () => {
                            const existing = this.weapons.find(w => w.type === 'holy');
                            if (existing) {
                                existing.level++;
                                existing.projectileCount++;
                            } else {
                                this.weapons.push({
                                    type: 'holy',
                                    level: 1,
                                    cooldown: 0,
                                    maxCooldown: 2,
                                    projectileCount: 1,
                                    range: 300
                                });
                            }
                        }
                    }
                ];
                
                // 根据等级解锁武器
                if (this.level >= 3) {
                    upgrades.push(...weaponUpgrades);
                }
                
                // 升级已有武器
                this.weapons.forEach(weapon => {
                    if (weapon.type !== 'sword' && weapon.level < 10) {
                        upgrades.push({
                            id: weapon.type + '_upgrade',
                            name: `⬆️ ${weapon.type === 'fireball' ? '火球' : weapon.type === 'lightning' ? '闪电' : '神圣'} 升级`,
                            description: `提升武器等级和效果`,
                            currentLevel: weapon.level,
                            apply: () => {
                                weapon.level++;
                                if (weapon.type === 'fireball') {
                                    weapon.projectileCount++;
                                } else if (weapon.type === 'lightning') {
                                    weapon.maxCooldown *= 0.9;
                                } else if (weapon.type === 'holy') {
                                    weapon.projectileCount++;
                                }
                            }
                        });
                    }
                });
                
                return upgrades;
            }
            
            applyUpgrade(upgrade) {
                upgrade.apply();
            }
            
            render(ctx) {
                // 绘制光环效果
                if (this.skills.aura > 0) {
                    const auraRadius = 150 * this.skills.aura;
                    const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, auraRadius);
                    gradient.addColorStop(0, 'rgba(255, 215, 0, 0.2)');
                    gradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, auraRadius, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // 绘制阴影
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.arc(this.x + 3, this.y + 3, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // 绘制玩家
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                
                // 绘制边框
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // 绘制眼睛
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(this.x - 7, this.y - 5, 3, 0, Math.PI * 2);
                ctx.arc(this.x + 7, this.y - 5, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // 敌人类
        class Enemy {
            constructor(x, y, type, healthMultiplier = 1) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.animationTimer = 0;
                
                // 根据类型设置属性
                switch(type) {
                    case 'zombie':
                        this.radius = 15;
                        this.maxHealth = 30 * healthMultiplier;
                        this.speed = 80;
                        this.damage = 10;
                        this.color = '#00ff00';
                        this.expValue = 10;
                        this.coinValue = 1;
                        break;
                    case 'ghost':
                        this.radius = 12;
                        this.maxHealth = 20 * healthMultiplier;
                        this.speed = 120;
                        this.damage = 15;
                        this.color = '#9370DB';
                        this.expValue = 15;
                        this.coinValue = 2;
                        break;
                    case 'demon':
                        this.radius = 20;
                        this.maxHealth = 50 * healthMultiplier;
                        this.speed = 60;
                        this.damage = 20;
                        this.color = '#ff0000';
                        this.expValue = 25;
                        this.coinValue = 3;
                        break;
                    case 'elite':
                        this.radius = 25;
                        this.maxHealth = 100 * healthMultiplier;
                        this.speed = 70;
                        this.damage = 30;
                        this.color = '#ff6600';
                        this.expValue = 50;
                        this.coinValue = 8;
                        this.isElite = true;
                        break;
                    case 'boss':
                        this.radius = 40;
                        this.maxHealth = 500 * healthMultiplier;
                        this.speed = 50;
                        this.damage = 40;
                        this.color = '#8B00FF';
                        this.expValue = 200;
                        this.coinValue = 50;
                        this.isBoss = true;
                        break;
                }
                
                this.health = this.maxHealth;
            }
            
            update(deltaTime, player) {
                this.animationTimer += deltaTime;
                
                // 追踪玩家
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > 0) {
                    this.x += (dx / dist) * this.speed * deltaTime;
                    this.y += (dy / dist) * this.speed * deltaTime;
                }
            }
            
            takeDamage(amount) {
                this.health -= amount;
            }
            
            render(ctx) {
                ctx.save();
                
                // Boss 特效
                if (this.isBoss) {
                    // 旋转光环
                    const rotation = this.animationTimer * 2;
                    const auraRadius = this.radius * 1.8;
                    
                    for (let i = 0; i < 6; i++) {
                        const angle = rotation + (i * Math.PI / 3);
                        const x = this.x + Math.cos(angle) * auraRadius;
                        const y = this.y + Math.sin(angle) * auraRadius;
                        
                        ctx.fillStyle = 'rgba(139, 0, 255, 0.3)';
                        ctx.beginPath();
                        ctx.arc(x, y, 8, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                // Elite 特效
                if (this.isElite) {
                    const pulseSize = this.radius * (1 + Math.sin(this.animationTimer * 5) * 0.2);
                    ctx.fillStyle = 'rgba(255, 102, 0, 0.2)';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, pulseSize * 1.3, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // 绘制血条
                if (this.health < this.maxHealth) {
                    const barWidth = this.radius * 2.5;
                    const barHeight = this.isBoss ? 8 : this.isElite ? 6 : 4;
                    const barX = this.x - barWidth / 2;
                    const barY = this.y - this.radius - 15;
                    
                    // 背景
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(barX - 2, barY - 2, barWidth + 4, barHeight + 4);
                    
                    // 血条
                    const gradient = ctx.createLinearGradient(barX, barY, barX + barWidth, barY);
                    gradient.addColorStop(0, '#ff0000');
                    gradient.addColorStop(1, '#ff6600');
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(barX, barY, barWidth * (this.health / this.maxHealth), barHeight);
                    
                    // 边框
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(barX, barY, barWidth, barHeight);
                }
                
                // 绘制敌人主体
                const pulseAmount = this.isBoss ? Math.sin(this.animationTimer * 3) * 0.1 : 0;
                const currentRadius = this.radius * (1 + pulseAmount);
                
                // 阴影
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.arc(this.x + 3, this.y + 3, currentRadius, 0, Math.PI * 2);
                ctx.fill();
                
                // 发光效果
                if (this.isBoss || this.isElite) {
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = this.color;
                }
                
                // 主体
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, currentRadius, 0, Math.PI * 2);
                ctx.fill();
                
                // 边框
                ctx.strokeStyle = this.isBoss ? '#FFD700' : this.isElite ? '#FFA500' : '#000';
                ctx.lineWidth = this.isBoss ? 4 : this.isElite ? 3 : 2;
                ctx.stroke();
                
                ctx.shadowBlur = 0;
                
                // Boss 眼睛
                if (this.isBoss) {
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(this.x - 12, this.y - 8, 6, 0, Math.PI * 2);
                    ctx.arc(this.x + 12, this.y - 8, 6, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // 眼睛高光
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(this.x - 10, this.y - 10, 3, 0, Math.PI * 2);
                    ctx.arc(this.x + 14, this.y - 10, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }

        // 弹药类
        class Projectile {
            constructor(x, y, angle, damage, speed, color, radius, pierce = 0, type = 'normal') {
                this.x = x;
                this.y = y;
                this.angle = angle;
                this.damage = damage;
                this.speed = speed;
                this.color = color;
                this.radius = radius;
                this.lifetime = 3;
                this.pierce = pierce;
                this.pierced = 0;
                this.type = type;
                
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                
                // 特效计时器
                this.effectTimer = 0;
            }
            
            update(deltaTime) {
                this.x += this.vx * deltaTime;
                this.y += this.vy * deltaTime;
                this.lifetime -= deltaTime;
                this.effectTimer += deltaTime;
            }
            
            render(ctx) {
                ctx.save();
                
                // 根据类型绘制不同效果
                if (this.type === 'fireball') {
                    // 火球拖尾效果
                    const trailLength = 3;
                    for (let i = 0; i < trailLength; i++) {
                        const alpha = 1 - (i / trailLength);
                        const offset = i * 10;
                        const tx = this.x - Math.cos(this.angle) * offset;
                        const ty = this.y - Math.sin(this.angle) * offset;
                        
                        ctx.globalAlpha = alpha * 0.5;
                        ctx.fillStyle = this.color;
                        ctx.beginPath();
                        ctx.arc(tx, ty, this.radius * (1 - i * 0.2), 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.globalAlpha = 1;
                } else if (this.type === 'lightning') {
                    // 闪电效果
                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = this.radius;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = this.color;
                    
                    const segments = 5;
                    const segmentLength = 20;
                    
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    
                    for (let i = 0; i < segments; i++) {
                        const offsetX = (Math.random() - 0.5) * 10;
                        const offsetY = (Math.random() - 0.5) * 10;
                        const px = this.x + Math.cos(this.angle) * segmentLength * i + offsetX;
                        const py = this.y + Math.sin(this.angle) * segmentLength * i + offsetY;
                        ctx.lineTo(px, py);
                    }
                    
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                } else if (this.type === 'holy') {
                    // 神圣光辉效果
                    const pulseSize = this.radius * (1 + Math.sin(this.effectTimer * 10) * 0.3);
                    
                    // 外圈光晕
                    const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, pulseSize * 2);
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                    gradient.addColorStop(0.5, 'rgba(255, 215, 0, 0.4)');
                    gradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, pulseSize * 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // 十字光芒
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.lineWidth = 3;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#ffffff';
                    
                    const crossSize = pulseSize * 1.5;
                    ctx.beginPath();
                    ctx.moveTo(this.x - crossSize, this.y);
                    ctx.lineTo(this.x + crossSize, this.y);
                    ctx.moveTo(this.x, this.y - crossSize);
                    ctx.lineTo(this.x, this.y + crossSize);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }
                
                // 核心弹药
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 15;
                ctx.shadowColor = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                
                ctx.restore();
            }
            
            canPierce() {
                return this.pierced < this.pierce;
            }
            
            onPierce() {
                this.pierced++;
            }
        }

        // 粒子类
        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.radius = Math.random() * 3 + 2;
                this.lifetime = 0.5;
                
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 100 + 50;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
            }
            
            update(deltaTime) {
                this.x += this.vx * deltaTime;
                this.y += this.vy * deltaTime;
                this.vx *= 0.95;
                this.vy *= 0.95;
                this.lifetime -= deltaTime;
            }
            
            render(ctx) {
                ctx.globalAlpha = this.lifetime / 0.5;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        // 掉落物类
        class Pickup {
            constructor(x, y, type, value) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.value = value;
                this.lifetime = 10;
                this.radius = 8;
                
                switch(type) {
                    case 'exp':
                        this.color = '#00ff00';
                        break;
                    case 'coin':
                        this.color = '#FFD700';
                        break;
                    case 'health':
                        this.color = '#ff0000';
                        break;
                }
            }
            
            update(deltaTime, player) {
                this.lifetime -= deltaTime;
                
                // 吸引向玩家
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < 100) {
                    const attractSpeed = 200;
                    this.x += (dx / dist) * attractSpeed * deltaTime;
                    this.y += (dy / dist) * attractSpeed * deltaTime;
                }
            }
            
            render(ctx) {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        // 伤害数字类
        class DamageNumber {
            constructor(x, y, damage) {
                this.x = x;
                this.y = y;
                this.damage = damage;
                this.lifetime = 1;
                this.vy = -100; // 向上飘
                this.opacity = 1;
            }
            
            update(deltaTime) {
                this.y += this.vy * deltaTime;
                this.lifetime -= deltaTime;
                this.opacity = this.lifetime;
            }
            
            render(ctx) {
                ctx.save();
                ctx.globalAlpha = this.opacity;
                ctx.fillStyle = '#ffff00';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.strokeText(this.damage.toString(), this.x, this.y);
                ctx.fillText(this.damage.toString(), this.x, this.y);
                ctx.restore();
            }
        }

        // 初始化游戏
        const game = new Game();
        game.showMainMenu();
    </script>
</body>
</html>
