<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>æš—å¤œå¹¸å­˜è€… - ç”Ÿå­˜å°„å‡»æ¸¸æˆ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #0f0f1e 100%);
            color: #fff;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            touch-action: none;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #gameCanvas {
            border: 2px solid #FFD700;
            background: #1a1a2e;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.3);
            max-width: 100%;
            max-height: 100%;
            display: block;
        }

        /* UIå±‚ */
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        /* é¡¶éƒ¨çŠ¶æ€æ  */
        #topBar {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            gap: 20px;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 10px;
            border: 2px solid #FFD700;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .stat-label {
            color: #FFD700;
            font-weight: bold;
        }

        .stat-value {
            color: #fff;
            font-size: 18px;
        }

        /* è¡€æ¡ */
        #healthBar {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;
            height: 30px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #FFD700;
            border-radius: 15px;
            overflow: hidden;
        }

        #healthFill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ff6600);
            transition: width 0.3s ease;
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
        }

        #healthText {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        /* ç»éªŒæ¡ */
        #expBar {
            position: absolute;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;
            height: 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #00ff00;
            border-radius: 10px;
            overflow: hidden;
        }

        #expFill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #00ff88);
            transition: width 0.3s ease;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }

        #expText {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 12px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        /* èœå•ç•Œé¢ */
        .menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 40px;
            border-radius: 20px;
            border: 3px solid #FFD700;
            text-align: center;
            pointer-events: auto;
            max-width: 90vw;
            max-height: 90vh;
            overflow-y: auto;
        }

        .menu h1 {
            color: #FFD700;
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        .menu h2 {
            color: #FFD700;
            font-size: 32px;
            margin-bottom: 20px;
        }

        .menu button {
            background: linear-gradient(135deg, #FFD700, #FFA500);
            color: #000;
            border: none;
            padding: 15px 40px;
            font-size: 20px;
            font-weight: bold;
            border-radius: 10px;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(255, 215, 0, 0.3);
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            min-height: 48px;
            min-width: 120px;
        }

        .menu button:hover,
        .menu button:active {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(255, 215, 0, 0.5);
        }

        /* å‡çº§é€‰æ‹© */
        #upgradeMenu {
            display: none;
        }

        .upgrade-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }

        .upgrade-card {
            background: rgba(26, 26, 46, 0.8);
            border: 2px solid #FFD700;
            border-radius: 15px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            min-height: 80px;
        }

        .upgrade-card:hover,
        .upgrade-card:active {
            transform: scale(1.05);
            border-color: #00ff00;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
        }

        .upgrade-card h3 {
            color: #FFD700;
            margin-bottom: 10px;
        }

        .upgrade-card p {
            color: #ccc;
            font-size: 14px;
        }

        .upgrade-card .level {
            color: #00ff00;
            font-size: 12px;
            margin-top: 10px;
        }

        /* å•†åº— */
        #shopMenu {
            display: none;
        }

        .shop-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .shop-item {
            background: rgba(26, 26, 46, 0.8);
            border: 2px solid #FFD700;
            border-radius: 10px;
            padding: 15px;
            text-align: center;
        }

        .shop-item h4 {
            color: #FFD700;
            margin-bottom: 10px;
        }

        .shop-item .price {
            color: #FFD700;
            font-size: 18px;
            font-weight: bold;
            margin: 10px 0;
        }

        .shop-item button {
            background: linear-gradient(135deg, #00ff00, #00cc00);
            color: #000;
            border: none;
            padding: 8px 20px;
            font-size: 14px;
            font-weight: bold;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            min-height: 44px;
        }

        .shop-item button:disabled {
            background: #666;
            cursor: not-allowed;
        }

        .shop-item button:active:not(:disabled) {
            transform: scale(0.95);
        }

        .shop-item .current-level {
            color: #00ff00;
            font-size: 12px;
            margin-top: 5px;
        }

        /* å…³å¡é€‰æ‹© */
        #levelSelect {
            display: none;
        }

        .level-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .level-card {
            background: rgba(26, 26, 46, 0.8);
            border: 2px solid #FFD700;
            border-radius: 10px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            min-height: 100px;
        }

        .level-card:hover,
        .level-card:active {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        .level-card.locked {
            opacity: 0.5;
            cursor: not-allowed;
            border-color: #666;
        }

        .level-card h3 {
            color: #FFD700;
            margin-bottom: 10px;
        }

        .level-card .difficulty {
            color: #ff6600;
            font-size: 14px;
            margin-top: 5px;
        }

        /* æ¸¸æˆç»“æŸ */
        #gameOverMenu {
            display: none;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 20px 0;
            text-align: left;
        }

        .stat-row {
            background: rgba(26, 26, 46, 0.5);
            padding: 10px;
            border-radius: 5px;
        }

        .stat-row span {
            color: #FFD700;
            font-weight: bold;
        }

        .hidden {
            display: none !important;
        }

        /* æ³¢æ¬¡æç¤º */
        #waveNotification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 64px;
            color: #FFD700;
            font-weight: bold;
            text-shadow: 0 0 30px rgba(255, 215, 0, 0.8);
            opacity: 0;
            transition: opacity 0.5s ease;
            pointer-events: none;
        }

        /* ä¼¤å®³æ•°å­— */
        .damage-number {
            position: absolute;
            font-size: 20px;
            font-weight: bold;
            pointer-events: none;
            animation: floatUp 1s ease-out forwards;
        }

        @keyframes floatUp {
            0% {
                opacity: 1;
                transform: translateY(0);
            }
            100% {
                opacity: 0;
                transform: translateY(-50px);
            }
        }

        /* ç§»åŠ¨ç«¯è™šæ‹Ÿæ‘‡æ† */
        #mobileControls {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 200px;
            pointer-events: none;
            display: none;
        }

        #joystick {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 120px;
            height: 120px;
            pointer-events: auto;
        }

        #joystickBase {
            position: absolute;
            width: 120px;
            height: 120px;
            background: radial-gradient(circle, rgba(255, 215, 0, 0.3), rgba(255, 215, 0, 0.1));
            border: 3px solid rgba(255, 215, 0, 0.5);
            border-radius: 50%;
        }

        #joystickStick {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 50px;
            height: 50px;
            background: radial-gradient(circle, #FFD700, #FFA500);
            border: 3px solid #fff;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.1s ease;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
        }

        /* ç§»åŠ¨ç«¯é€‚é… */
        @media (max-width: 768px) {
            #mobileControls {
                display: block;
            }

            .menu {
                padding: 20px;
                max-width: 95vw;
            }

            .menu h1 {
                font-size: 32px;
            }

            .menu h2 {
                font-size: 24px;
            }

            .menu button {
                padding: 12px 30px;
                font-size: 18px;
                width: 100%;
                max-width: 300px;
            }

            #topBar {
                flex-wrap: wrap;
                gap: 5px;
                top: 10px;
                left: 10px;
                right: 10px;
            }

            .stat-box {
                padding: 5px 10px;
                font-size: 12px;
            }

            .stat-value {
                font-size: 14px;
            }

            #healthBar, #expBar {
                width: 90%;
            }

            .upgrade-grid, .shop-grid, .level-grid {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 480px) {
            .menu h1 {
                font-size: 24px;
            }

            .menu button {
                padding: 10px 20px;
                font-size: 16px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="1200" height="700"></canvas>
        
        <div id="ui">
            <!-- é¡¶éƒ¨çŠ¶æ€æ  -->
            <div id="topBar">
                <div class="stat-box">
                    <span class="stat-label">ç­‰çº§:</span>
                    <span class="stat-value" id="levelDisplay">1</span>
                </div>
                <div class="stat-box">
                    <span class="stat-label">ğŸ’° é‡‘å¸:</span>
                    <span class="stat-value" id="coinDisplay">0</span>
                </div>
                <div class="stat-box">
                    <span class="stat-label">â±ï¸ æ—¶é—´:</span>
                    <span class="stat-value" id="timeDisplay">0:00</span>
                </div>
                <div class="stat-box">
                    <span class="stat-label">ğŸ’€ å‡»æ€:</span>
                    <span class="stat-value" id="killDisplay">0</span>
                </div>
            </div>

            <!-- è¡€æ¡ -->
            <div id="healthBar">
                <div id="healthFill" style="width: 100%;"></div>
                <div id="healthText">100 / 100</div>
            </div>

            <!-- ç»éªŒæ¡ -->
            <div id="expBar">
                <div id="expFill" style="width: 0%;"></div>
                <div id="expText">0 / 100</div>
            </div>

            <!-- æ³¢æ¬¡æç¤º -->
            <div id="waveNotification"></div>

            <!-- ç§»åŠ¨ç«¯è™šæ‹Ÿæ‘‡æ† -->
            <div id="mobileControls">
                <div id="joystick">
                    <div id="joystickBase"></div>
                    <div id="joystickStick"></div>
                </div>
            </div>

            <!-- ä¸»èœå• -->
            <div id="mainMenu" class="menu">
                <h1>ğŸ§› æš—å¤œå¹¸å­˜è€… ğŸ§›</h1>
                <p style="margin-bottom: 30px;">åœ¨æ— å°½çš„é»‘æš—ä¸­ç”Ÿå­˜ï¼Œå‡çº§ä½ çš„è§’è‰²ï¼Œè§£é”å¼ºå¤§çš„æ­¦å™¨å’ŒæŠ€èƒ½ï¼</p>
                <button id="startGameBtn">å¼€å§‹æ¸¸æˆ</button>
                <button id="shopBtn">æ°¸ä¹…å‡çº§å•†åº—</button>
                <div style="margin-top: 30px;">
                    <h3 style="color: #FFD700;">æ¸¸æˆè¯´æ˜</h3>
                    <p id="gameInstructions" style="font-size: 14px; color: #ccc; margin-top: 10px; text-align: left;">
                        ğŸ® ä½¿ç”¨ WASD æˆ–æ–¹å‘é”®ç§»åŠ¨<br>
                        ğŸ—¡ï¸ è‡ªåŠ¨æ”»å‡»é™„è¿‘çš„æ•Œäºº<br>
                        â¬†ï¸ å‡»è´¥æ•Œäººè·å¾—ç»éªŒå‡çº§ï¼Œé€‰æ‹©å¼ºå¤§çš„æŠ€èƒ½<br>
                        ğŸ’° æ”¶é›†é‡‘å¸è¿›è¡Œæ°¸ä¹…å‡çº§<br>
                        ğŸ¯ æ¯ä¸ªå…³å¡éƒ½æœ‰ç‹¬ç‰¹çš„æŒ‘æˆ˜å’ŒBoss<br>
                        ğŸ† æ´»å¾—è¶Šä¹…ï¼Œå¥–åŠ±è¶Šä¸°åšï¼
                    </p>
                </div>
            </div>

            <!-- å…³å¡é€‰æ‹© -->
            <div id="levelSelect" class="menu">
                <h2>é€‰æ‹©å…³å¡</h2>
                <div class="level-grid" id="levelGrid"></div>
                <button id="levelBackBtn">è¿”å›</button>
            </div>

            <!-- å‡çº§èœå• -->
            <div id="upgradeMenu" class="menu">
                <h2>é€‰æ‹©å‡çº§</h2>
                <p>é€‰æ‹©ä¸€ä¸ªå‡çº§æ¥å¢å¼ºä½ çš„èƒ½åŠ›ï¼</p>
                <div class="upgrade-grid" id="upgradeGrid"></div>
            </div>

            <!-- å•†åº—èœå• -->
            <div id="shopMenu" class="menu">
                <h2>æ°¸ä¹…å‡çº§å•†åº—</h2>
                <p>ğŸ’° ä½ çš„é‡‘å¸: <span id="shopCoins">0</span></p>
                <div class="shop-grid" id="shopGrid"></div>
                <button id="shopBackBtn">è¿”å›</button>
            </div>

            <!-- æ¸¸æˆç»“æŸ -->
            <div id="gameOverMenu" class="menu">
                <h1 id="gameOverTitle">æ¸¸æˆç»“æŸ</h1>
                <div class="stats-grid" id="gameStats"></div>
                <div style="margin-top: 20px;">
                    <button id="restartBtn">é‡æ–°å¼€å§‹</button>
                    <button id="gameOverBackBtn">è¿”å›ä¸»èœå•</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // æ¸¸æˆä¸»ç±»
        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.width = this.canvas.width;
                this.height = this.canvas.height;
                
                // æ¸¸æˆçŠ¶æ€
                this.state = 'menu'; // menu, playing, paused, upgrading, gameOver
                this.currentLevel = null;
                
                // ç©å®¶æ•°æ®
                this.player = null;
                this.enemies = [];
                this.projectiles = [];
                this.particles = [];
                this.pickups = [];
                
                // æ¸¸æˆæ•°æ®
                this.kills = 0;
                this.totalCoins = parseInt(localStorage.getItem('totalCoins') || '0');
                this.gameTime = 0;
                this.wave = 0;
                this.waveTimer = 0;
                this.damageNumbers = [];
                
                // æ°¸ä¹…å‡çº§
                this.permanentUpgrades = JSON.parse(localStorage.getItem('permanentUpgrades') || '{}');
                
                // è¾“å…¥
                this.keys = {};
                this.touchInput = { x: 0, y: 0, active: false };
                this.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                
                // å…³å¡å®šä¹‰
                this.levels = [
                    {
                        id: 1,
                        name: 'æš—å¤œæ£®æ—',
                        difficulty: 'ç®€å•',
                        enemySpawnRate: 2,
                        enemyHealthMultiplier: 1,
                        duration: 300, // 5åˆ†é’Ÿ
                        unlocked: true
                    },
                    {
                        id: 2,
                        name: 'è¢«è¯…å’’çš„å¢“åœ°',
                        difficulty: 'ä¸­ç­‰',
                        enemySpawnRate: 3,
                        enemyHealthMultiplier: 1.5,
                        duration: 420,
                        unlocked: false
                    },
                    {
                        id: 3,
                        name: 'æ¶é­”åŸå ¡',
                        difficulty: 'å›°éš¾',
                        enemySpawnRate: 4,
                        enemyHealthMultiplier: 2,
                        duration: 600,
                        unlocked: false
                    },
                    {
                        id: 4,
                        name: 'åœ°ç‹±ä¹‹é—¨',
                        difficulty: 'å™©æ¢¦',
                        enemySpawnRate: 5,
                        enemyHealthMultiplier: 3,
                        duration: 900,
                        unlocked: false
                    }
                ];
                
                this.setupEventListeners();
                this.setupButtonListeners();
                this.updateShopDisplay();
                this.resizeCanvas();
                
                // æ›´æ–°ç§»åŠ¨ç«¯è¯´æ˜
                if (this.isMobile) {
                    const instructions = document.getElementById('gameInstructions');
                    if (instructions) {
                        instructions.innerHTML = `
                            ğŸ® ä½¿ç”¨å±å¹•å·¦ä¸‹è§’çš„è™šæ‹Ÿæ‘‡æ†ç§»åŠ¨<br>
                            ğŸ—¡ï¸ è‡ªåŠ¨æ”»å‡»é™„è¿‘çš„æ•Œäºº<br>
                            â¬†ï¸ å‡»è´¥æ•Œäººè·å¾—ç»éªŒå‡çº§ï¼Œé€‰æ‹©å¼ºå¤§çš„æŠ€èƒ½<br>
                            ğŸ’° æ”¶é›†é‡‘å¸è¿›è¡Œæ°¸ä¹…å‡çº§<br>
                            ğŸ¯ æ¯ä¸ªå…³å¡éƒ½æœ‰ç‹¬ç‰¹çš„æŒ‘æˆ˜å’ŒBoss<br>
                            ğŸ† æ´»å¾—è¶Šä¹…ï¼Œå¥–åŠ±è¶Šä¸°åšï¼
                        `;
                    }
                }
            }
            
            resizeCanvas() {
                const container = document.getElementById('gameContainer');
                const containerWidth = container.clientWidth;
                const containerHeight = container.clientHeight;
                
                const gameAspect = 1200 / 700;
                const containerAspect = containerWidth / containerHeight;
                
                if (containerAspect > gameAspect) {
                    this.canvas.style.height = containerHeight + 'px';
                    this.canvas.style.width = (containerHeight * gameAspect) + 'px';
                } else {
                    this.canvas.style.width = containerWidth + 'px';
                    this.canvas.style.height = (containerWidth / gameAspect) + 'px';
                }
            }
            
            setupEventListeners() {
                // é”®ç›˜äº‹ä»¶
                document.addEventListener('keydown', (e) => {
                    this.keys[e.key] = true;
                    if (e.key === 'Escape' && this.state === 'playing') {
                        this.pauseGame();
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.key] = false;
                });

                // çª—å£å¤§å°è°ƒæ•´
                window.addEventListener('resize', () => this.resizeCanvas());

                // ç§»åŠ¨ç«¯è™šæ‹Ÿæ‘‡æ†
                if (this.isMobile) {
                    this.setupJoystick();
                }
            }

            setupJoystick() {
                const joystick = document.getElementById('joystick');
                const joystickStick = document.getElementById('joystickStick');
                const joystickBase = document.getElementById('joystickBase');
                
                let touchId = null;
                const maxDistance = 35;
                
                const handleTouchStart = (e) => {
                    if (this.state !== 'playing') return;
                    e.preventDefault();
                    const touch = e.touches[0];
                    touchId = touch.identifier;
                };
                
                const handleTouchMove = (e) => {
                    if (this.state !== 'playing' || touchId === null) return;
                    e.preventDefault();
                    
                    const touch = Array.from(e.touches).find(t => t.identifier === touchId);
                    if (!touch) return;
                    
                    const rect = joystickBase.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    
                    let dx = touch.clientX - centerX;
                    let dy = touch.clientY - centerY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > maxDistance) {
                        dx = (dx / distance) * maxDistance;
                        dy = (dy / distance) * maxDistance;
                    }
                    
                    joystickStick.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
                    
                    // è®¾ç½®è§¦æ‘¸è¾“å…¥
                    this.touchInput.x = dx / maxDistance;
                    this.touchInput.y = dy / maxDistance;
                    this.touchInput.active = true;
                };
                
                const handleTouchEnd = (e) => {
                    if (touchId === null) return;
                    e.preventDefault();
                    
                    const touches = Array.from(e.changedTouches);
                    if (touches.some(t => t.identifier === touchId)) {
                        touchId = null;
                        joystickStick.style.transform = 'translate(-50%, -50%)';
                        this.touchInput.x = 0;
                        this.touchInput.y = 0;
                        this.touchInput.active = false;
                    }
                };
                
                joystick.addEventListener('touchstart', handleTouchStart, { passive: false });
                joystick.addEventListener('touchmove', handleTouchMove, { passive: false });
                joystick.addEventListener('touchend', handleTouchEnd, { passive: false });
                joystick.addEventListener('touchcancel', handleTouchEnd, { passive: false });
            }

            setupButtonListeners() {
                // ä¸»èœå•æŒ‰é’®
                const startGameBtn = document.getElementById('startGameBtn');
                const shopBtn = document.getElementById('shopBtn');
                
                if (startGameBtn) {
                    startGameBtn.addEventListener('click', () => this.showLevelSelect());
                    startGameBtn.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        this.showLevelSelect();
                    });
                }
                
                if (shopBtn) {
                    shopBtn.addEventListener('click', () => this.showShop());
                    shopBtn.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        this.showShop();
                    });
                }
                
                // è¿”å›æŒ‰é’®
                const levelBackBtn = document.getElementById('levelBackBtn');
                const shopBackBtn = document.getElementById('shopBackBtn');
                const gameOverBackBtn = document.getElementById('gameOverBackBtn');
                const restartBtn = document.getElementById('restartBtn');
                
                if (levelBackBtn) {
                    levelBackBtn.addEventListener('click', () => this.showMainMenu());
                    levelBackBtn.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        this.showMainMenu();
                    });
                }
                
                if (shopBackBtn) {
                    shopBackBtn.addEventListener('click', () => this.hideShop());
                    shopBackBtn.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        this.hideShop();
                    });
                }
                
                if (gameOverBackBtn) {
                    gameOverBackBtn.addEventListener('click', () => this.showMainMenu());
                    gameOverBackBtn.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        this.showMainMenu();
                    });
                }
                
                if (restartBtn) {
                    restartBtn.addEventListener('click', () => this.restart());
                    restartBtn.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        this.restart();
                    });
                }
            }
            
            showMainMenu() {
                this.state = 'menu';
                document.getElementById('mainMenu').classList.remove('hidden');
                document.getElementById('levelSelect').classList.add('hidden');
                document.getElementById('upgradeMenu').classList.add('hidden');
                document.getElementById('shopMenu').classList.add('hidden');
                document.getElementById('gameOverMenu').classList.add('hidden');
            }
            
            showLevelSelect() {
                this.state = 'levelSelect';
                document.getElementById('mainMenu').classList.add('hidden');
                document.getElementById('levelSelect').classList.remove('hidden');
                
                const grid = document.getElementById('levelGrid');
                grid.innerHTML = '';
                
                this.levels.forEach(level => {
                    const card = document.createElement('div');
                    card.className = 'level-card' + (level.unlocked ? '' : ' locked');
                    card.innerHTML = `
                        <h3>${level.name}</h3>
                        <p>å…³å¡ ${level.id}</p>
                        <p class="difficulty">éš¾åº¦: ${level.difficulty}</p>
                        <p style="font-size: 12px; color: #ccc; margin-top: 10px;">
                            æŒç»­æ—¶é—´: ${Math.floor(level.duration / 60)}:${(level.duration % 60).toString().padStart(2, '0')}
                        </p>
                    `;
                    
                    if (level.unlocked) {
                        const startLevel = () => this.startLevel(level);
                        card.onclick = startLevel;
                        card.addEventListener('touchend', (e) => {
                            e.preventDefault();
                            startLevel();
                        });
                        card.style.cursor = 'pointer';
                    }
                    
                    grid.appendChild(card);
                });
            }
            
            startLevel(level) {
                this.currentLevel = level;
                this.state = 'playing';
                this.gameTime = 0;
                this.kills = 0;
                this.wave = 0;
                this.waveTimer = 0;
                
                // éšè—æ‰€æœ‰èœå•
                document.getElementById('mainMenu').classList.add('hidden');
                document.getElementById('levelSelect').classList.add('hidden');
                document.getElementById('upgradeMenu').classList.add('hidden');
                document.getElementById('shopMenu').classList.add('hidden');
                document.getElementById('gameOverMenu').classList.add('hidden');
                
                // åˆå§‹åŒ–ç©å®¶
                this.player = new Player(this.width / 2, this.height / 2);
                this.enemies = [];
                this.projectiles = [];
                this.particles = [];
                this.pickups = [];
                this.damageNumbers = [];
                
                console.log('ç©å®¶åˆ›å»ºå®Œæˆ:', this.player);
                console.log('æ¸¸æˆçŠ¶æ€:', this.state);
                console.log('ç”»å¸ƒå°ºå¯¸:', this.width, 'x', this.height);
                
                // ç«‹å³æ·»åŠ ä¸€ä¸ªæµ‹è¯•æ•Œäºº
                this.enemies.push(new Enemy(this.width / 2 + 100, this.height / 2, 'zombie', 1));
                console.log('æ·»åŠ æµ‹è¯•æ•Œäººï¼Œæ€»æ•Œäººæ•°:', this.enemies.length);
                
                // å¼€å§‹æ¸¸æˆå¾ªç¯
                this.lastTime = performance.now();
                this.gameLoop();
            }
            
            gameLoop(currentTime = performance.now()) {
                if (this.state !== 'playing') {
                    console.log('æ¸¸æˆå¾ªç¯åœæ­¢ï¼ŒçŠ¶æ€:', this.state);
                    return;
                }
                
                const deltaTime = (currentTime - this.lastTime) / 1000;
                this.lastTime = currentTime;
                
                this.update(deltaTime);
                this.render();
                
                requestAnimationFrame((time) => this.gameLoop(time));
            }
            
            update(deltaTime) {
                // æ›´æ–°æ¸¸æˆæ—¶é—´
                this.gameTime += deltaTime;
                
                // æ£€æŸ¥æ˜¯å¦é€šå…³
                if (this.gameTime >= this.currentLevel.duration) {
                    this.levelComplete();
                    return;
                }
                
                // æ›´æ–°æ³¢æ¬¡
                this.waveTimer += deltaTime;
                if (this.waveTimer >= 30) { // æ¯30ç§’ä¸€æ³¢
                    this.waveTimer = 0;
                    this.wave++;
                    this.showWaveNotification(this.wave);
                }
                
                // æ›´æ–°ç©å®¶
                this.player.update(deltaTime, this.keys, this);
                
                // ç”Ÿæˆæ•Œäºº
                this.spawnEnemies(deltaTime);
                
                
                // æ›´æ–°æ•Œäºº
                this.enemies = this.enemies.filter(enemy => {
                    enemy.update(deltaTime, this.player);
                    
                    // æ£€æŸ¥ä¸ç©å®¶ç¢°æ’
                    const dx = enemy.x - this.player.x;
                    const dy = enemy.y - this.player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < enemy.radius + this.player.radius) {
                        this.player.takeDamage(enemy.damage);
                        enemy.health = 0;
                    }
                    
                    if (enemy.health <= 0) {
                        this.enemyKilled(enemy);
                        return false;
                    }
                    return true;
                });
                
                // æ›´æ–°å¼¹è¯
                this.projectiles = this.projectiles.filter(proj => {
                    proj.update(deltaTime);
                    
                    let hitEnemy = false;
                    
                    // æ£€æŸ¥ä¸æ•Œäººç¢°æ’
                    for (let enemy of this.enemies) {
                        const dx = proj.x - enemy.x;
                        const dy = proj.y - enemy.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < enemy.radius + proj.radius) {
                            const actualDamage = proj.damage;
                            enemy.takeDamage(actualDamage);
                            
                            // æ˜¾ç¤ºä¼¤å®³æ•°å­—
                            this.damageNumbers.push(new DamageNumber(proj.x, proj.y, Math.floor(actualDamage)));
                            
                            // ç”Ÿå‘½å·å–
                            if (this.player.skills.lifeSteal > 0) {
                                const healAmount = actualDamage * 0.05 * this.player.skills.lifeSteal;
                                this.player.heal(healAmount);
                            }
                            
                            this.createHitEffect(proj.x, proj.y, proj.color);
                            
                            // æ£€æŸ¥ç©¿é€
                            if (proj.canPierce()) {
                                proj.onPierce();
                                hitEnemy = true;
                                break; // åªå‡»ä¸­ä¸€ä¸ªæ•Œäººåç»§ç»­
                            } else {
                                return false; // æ²¡æœ‰ç©¿é€ï¼Œå¼¹è¯æ¶ˆå¤±
                            }
                        }
                    }
                    
                    // æ£€æŸ¥æ˜¯å¦è¶…å‡ºèŒƒå›´
                    return proj.lifetime > 0;
                });
                
                // æ›´æ–°ç²’å­
                this.particles = this.particles.filter(p => {
                    p.update(deltaTime);
                    return p.lifetime > 0;
                });
                
                // æ›´æ–°ä¼¤å®³æ•°å­—
                this.damageNumbers = this.damageNumbers.filter(d => {
                    d.update(deltaTime);
                    return d.lifetime > 0;
                });
                
                // æ›´æ–°æ‰è½ç‰©
                this.pickups = this.pickups.filter(pickup => {
                    pickup.update(deltaTime, this.player);
                    
                    const dx = pickup.x - this.player.x;
                    const dy = pickup.y - this.player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < 30) {
                        if (pickup.type === 'exp') {
                            this.player.addExp(pickup.value);
                        } else if (pickup.type === 'coin') {
                            this.player.coins += pickup.value;
                        } else if (pickup.type === 'health') {
                            this.player.heal(pickup.value);
                        }
                        return false;
                    }
                    
                    return pickup.lifetime > 0;
                });
                
                // æ›´æ–°UI
                this.updateUI();
                
                // æ£€æŸ¥ç©å®¶æ˜¯å¦æ­»äº¡
                if (this.player.health <= 0) {
                    this.gameOver(false);
                }
            }
            
            render() {
                // æ¸…ç©ºç”»å¸ƒ
                this.ctx.fillStyle = '#1a1a2e';
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                // ç»˜åˆ¶ç½‘æ ¼èƒŒæ™¯
                this.ctx.strokeStyle = 'rgba(255, 215, 0, 0.1)';
                this.ctx.lineWidth = 1;
                for (let x = 0; x < this.width; x += 50) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.height);
                    this.ctx.stroke();
                }
                for (let y = 0; y < this.height; y += 50) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.width, y);
                    this.ctx.stroke();
                }
                
                // ç»˜åˆ¶æ‰è½ç‰©
                this.pickups.forEach(p => p.render(this.ctx));
                
                // ç»˜åˆ¶ç²’å­
                this.particles.forEach(p => p.render(this.ctx));
                
                // ç»˜åˆ¶ä¼¤å®³æ•°å­—
                this.damageNumbers.forEach(d => d.render(this.ctx));
                
                // ç»˜åˆ¶å¼¹è¯
                this.projectiles.forEach(p => p.render(this.ctx));
                
                // ç»˜åˆ¶æ•Œäºº
                // ç»˜åˆ¶æ•Œäºº
                console.log('æ¸²æŸ“æ•Œäººæ•°é‡:', this.enemies.length);
                this.enemies.forEach(e => e.render(this.ctx));
                
                // ç»˜åˆ¶ç©å®¶
                if (this.player) {
                    console.log('æ¸²æŸ“ç©å®¶ä½ç½®:', this.player.x, this.player.y);
                    this.player.render(this.ctx);
                } else {
                    console.log('ç©å®¶ä¸å­˜åœ¨ï¼Œæ— æ³•æ¸²æŸ“');
                }
                
            }
            
            spawnEnemies(deltaTime) {
                const spawnRate = this.currentLevel.enemySpawnRate * (1 + this.wave * 0.1);
                const spawnChance = spawnRate * deltaTime;
                
                if (Math.random() < spawnChance) {
                    // åœ¨å±å¹•å¤–ç”Ÿæˆ
                    const side = Math.floor(Math.random() * 4);
                    let x, y;
                    
                    switch(side) {
                        case 0: // ä¸Š
                            x = Math.random() * this.width;
                            y = -30;
                            break;
                        case 1: // å³
                            x = this.width + 30;
                            y = Math.random() * this.height;
                            break;
                        case 2: // ä¸‹
                            x = Math.random() * this.width;
                            y = this.height + 30;
                            break;
                        case 3: // å·¦
                            x = -30;
                            y = Math.random() * this.height;
                            break;
                    }
                    
                    // éšæœºæ•Œäººç±»å‹ï¼Œæ³¢æ¬¡è¶Šé«˜ï¼Œé«˜çº§æ•Œäººå‡ ç‡è¶Šå¤§
                    let type;
                    const roll = Math.random();
                    
                    if (this.wave >= 10 && roll < 0.05) {
                        type = 'boss';
                    } else if (this.wave >= 5 && roll < 0.15) {
                        type = 'elite';
                    } else if (roll < 0.5) {
                        type = 'zombie';
                    } else if (roll < 0.8) {
                        type = 'ghost';
                    } else {
                        type = 'demon';
                    }
                    
                    this.enemies.push(new Enemy(x, y, type, this.currentLevel.enemyHealthMultiplier * (1 + this.wave * 0.2)));
                }
                
                // Boss ç”Ÿæˆï¼ˆæ¯5æ³¢ï¼‰
                if (this.wave > 0 && this.wave % 5 === 0 && this.waveTimer < 1) {
                    const bossExists = this.enemies.some(e => e.type === 'boss');
                    if (!bossExists) {
                        const x = this.width / 2;
                        const y = -50;
                        this.enemies.push(new Enemy(x, y, 'boss', this.currentLevel.enemyHealthMultiplier * (1 + this.wave * 0.3)));
                        this.showWaveNotification(`Boss å‡ºç°ï¼`);
                    }
                }
            }
            
            enemyKilled(enemy) {
                this.kills++;
                this.player.coins += enemy.coinValue;
                
                // åˆ›å»ºæ‰è½ç‰©
                if (Math.random() < 0.8) {
                    this.pickups.push(new Pickup(enemy.x, enemy.y, 'exp', enemy.expValue));
                }
                if (Math.random() < 0.3) {
                    this.pickups.push(new Pickup(enemy.x, enemy.y, 'coin', enemy.coinValue * 2));
                }
                if (Math.random() < 0.1 && this.player.health < this.player.maxHealth) {
                    this.pickups.push(new Pickup(enemy.x, enemy.y, 'health', 20));
                }
                
                // åˆ›å»ºæ­»äº¡ç²’å­
                const particleCount = enemy.isBoss ? 50 : enemy.isElite ? 30 : 10;
                for (let i = 0; i < particleCount; i++) {
                    this.particles.push(new Particle(enemy.x, enemy.y, enemy.color));
                }
                
                // Boss å‡»æ€ç‰¹æ•ˆ
                if (enemy.isBoss) {
                    this.showWaveNotification('Boss å‡»è´¥ï¼');
                }
            }
            
            createHitEffect(x, y, color = '#ffff00') {
                for (let i = 0; i < 5; i++) {
                    this.particles.push(new Particle(x, y, color));
                }
            }
            
            showUpgradeMenu() {
                this.state = 'upgrading';
                document.getElementById('upgradeMenu').classList.remove('hidden');
                
                const grid = document.getElementById('upgradeGrid');
                grid.innerHTML = '';
                
                // ç”Ÿæˆ3ä¸ªéšæœºå‡çº§é€‰é¡¹
                const availableUpgrades = this.player.getAvailableUpgrades();
                const shuffled = availableUpgrades.sort(() => Math.random() - 0.5);
                const options = shuffled.slice(0, 3);
                
                options.forEach(upgrade => {
                    const card = document.createElement('div');
                    card.className = 'upgrade-card';
                    card.innerHTML = `
                        <h3>${upgrade.name}</h3>
                        <p>${upgrade.description}</p>
                        <p class="level">ç­‰çº§ ${upgrade.currentLevel} â†’ ${upgrade.currentLevel + 1}</p>
                    `;
                    const applyUpgrade = () => {
                        this.player.applyUpgrade(upgrade);
                        document.getElementById('upgradeMenu').classList.add('hidden');
                        this.state = 'playing';
                        this.lastTime = performance.now();
                        this.gameLoop();
                    };
                    
                    card.onclick = applyUpgrade;
                    card.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        applyUpgrade();
                    });
                    
                    grid.appendChild(card);
                });
            }
            
            showShop() {
                document.getElementById('mainMenu').classList.add('hidden');
                document.getElementById('shopMenu').classList.remove('hidden');
                this.updateShopDisplay();
            }
            
            hideShop() {
                document.getElementById('shopMenu').classList.add('hidden');
                document.getElementById('mainMenu').classList.remove('hidden');
            }
            
            updateShopDisplay() {
                document.getElementById('shopCoins').textContent = this.totalCoins;
                document.getElementById('coinDisplay').textContent = this.totalCoins;
                
                const grid = document.getElementById('shopGrid');
                grid.innerHTML = '';
                
                const shopItems = [
                    { id: 'maxHealth', name: 'æœ€å¤§ç”Ÿå‘½å€¼', basePrice: 50, increment: 20 },
                    { id: 'damage', name: 'ä¼¤å®³åŠ æˆ', basePrice: 100, increment: 0.1 },
                    { id: 'moveSpeed', name: 'ç§»åŠ¨é€Ÿåº¦', basePrice: 75, increment: 5 },
                    { id: 'attackSpeed', name: 'æ”»å‡»é€Ÿåº¦', basePrice: 100, increment: 0.1 },
                    { id: 'expMultiplier', name: 'ç»éªŒåŠ æˆ', basePrice: 150, increment: 0.1 },
                    { id: 'coinMultiplier', name: 'é‡‘å¸åŠ æˆ', basePrice: 150, increment: 0.1 }
                ];
                
                shopItems.forEach(item => {
                    const level = this.permanentUpgrades[item.id] || 0;
                    const price = Math.floor(item.basePrice * Math.pow(1.5, level));
                    
                    const div = document.createElement('div');
                    div.className = 'shop-item';
                    div.innerHTML = `
                        <h4>${item.name}</h4>
                        <p class="current-level">ç­‰çº§: ${level}</p>
                        <p class="price">${price} ğŸ’°</p>
                        <button ${this.totalCoins < price ? 'disabled' : ''} data-item-id="${item.id}" data-price="${price}" class="shop-buy-btn">
                            è´­ä¹°
                        </button>
                    `;
                    
                    const buyBtn = div.querySelector('.shop-buy-btn');
                    if (buyBtn && !buyBtn.disabled) {
                        const buyUpgrade = () => this.buyUpgrade(item.id, price);
                        buyBtn.addEventListener('click', buyUpgrade);
                        buyBtn.addEventListener('touchend', (e) => {
                            e.preventDefault();
                            buyUpgrade();
                        });
                    }
                    
                    grid.appendChild(div);
                });
            }
            
            buyUpgrade(id, price) {
                if (this.totalCoins >= price) {
                    this.totalCoins -= price;
                    this.permanentUpgrades[id] = (this.permanentUpgrades[id] || 0) + 1;
                    localStorage.setItem('totalCoins', this.totalCoins.toString());
                    localStorage.setItem('permanentUpgrades', JSON.stringify(this.permanentUpgrades));
                    this.updateShopDisplay();
                }
            }
            
            updateUI() {
                document.getElementById('levelDisplay').textContent = this.player.level;
                document.getElementById('coinDisplay').textContent = this.player.coins;
                document.getElementById('killDisplay').textContent = this.kills;
                
                const minutes = Math.floor(this.gameTime / 60);
                const seconds = Math.floor(this.gameTime % 60);
                document.getElementById('timeDisplay').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                
                const healthPercent = (this.player.health / this.player.maxHealth) * 100;
                document.getElementById('healthFill').style.width = healthPercent + '%';
                document.getElementById('healthText').textContent = `${Math.ceil(this.player.health)} / ${this.player.maxHealth}`;
                
                const expPercent = (this.player.exp / this.player.expToNextLevel) * 100;
                document.getElementById('expFill').style.width = expPercent + '%';
                document.getElementById('expText').textContent = `${Math.floor(this.player.exp)} / ${this.player.expToNextLevel}`;
            }
            
            showWaveNotification(wave) {
                const notification = document.getElementById('waveNotification');
                notification.textContent = `ç¬¬ ${wave} æ³¢ï¼`;
                notification.style.opacity = '1';
                
                setTimeout(() => {
                    notification.style.opacity = '0';
                }, 2000);
            }
            
            levelComplete() {
                this.gameOver(true);
            }
            
            gameOver(victory) {
                this.state = 'gameOver';
                
                // ä¿å­˜é‡‘å¸
                this.totalCoins += this.player.coins;
                localStorage.setItem('totalCoins', this.totalCoins.toString());
                
                // è§£é”ä¸‹ä¸€å…³
                if (victory && this.currentLevel.id < this.levels.length) {
                    this.levels[this.currentLevel.id].unlocked = true;
                }
                
                // æ˜¾ç¤ºæ¸¸æˆç»“æŸç•Œé¢
                document.getElementById('gameOverTitle').textContent = victory ? 'ğŸ‰ å…³å¡å®Œæˆï¼ğŸ‰' : 'ğŸ’€ æ¸¸æˆç»“æŸ ğŸ’€';
                
                const statsGrid = document.getElementById('gameStats');
                const minutes = Math.floor(this.gameTime / 60);
                const seconds = Math.floor(this.gameTime % 60);
                
                statsGrid.innerHTML = `
                    <div class="stat-row"><span>å­˜æ´»æ—¶é—´:</span> ${minutes}:${seconds.toString().padStart(2, '0')}</div>
                    <div class="stat-row"><span>å‡»æ€æ•°:</span> ${this.kills}</div>
                    <div class="stat-row"><span>ç­‰çº§:</span> ${this.player.level}</div>
                    <div class="stat-row"><span>é‡‘å¸:</span> ${this.player.coins}</div>
                `;
                
                document.getElementById('gameOverMenu').classList.remove('hidden');
            }
            
            restart() {
                document.getElementById('gameOverMenu').classList.add('hidden');
                if (this.currentLevel) {
                    this.startLevel(this.currentLevel);
                }
            }
            
            pauseGame() {
                // æš‚åœåŠŸèƒ½
                this.state = 'paused';
            }
        }

        // ç©å®¶ç±»
        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 20;
                this.color = '#FFD700';
                
                // å±æ€§
                this.maxHealth = 100 + (game.permanentUpgrades.maxHealth || 0) * 20;
                this.health = this.maxHealth;
                this.moveSpeed = 200 + (game.permanentUpgrades.moveSpeed || 0) * 5;
                this.damage = 10 + (game.permanentUpgrades.damage || 0) * 0.1;
                this.attackSpeed = 1 + (game.permanentUpgrades.attackSpeed || 0) * 0.1;
                
                // ç»éªŒå’Œç­‰çº§
                this.level = 1;
                this.exp = 0;
                this.expToNextLevel = 100;
                this.expMultiplier = 1 + (game.permanentUpgrades.expMultiplier || 0) * 0.1;
                
                // é‡‘å¸
                this.coins = 0;
                this.coinMultiplier = 1 + (game.permanentUpgrades.coinMultiplier || 0) * 0.1;
                
                // æ­¦å™¨
                this.weapons = [
                    { 
                        type: 'sword', 
                        level: 1, 
                        cooldown: 0, 
                        maxCooldown: 1 / this.attackSpeed,
                        projectileCount: 1,
                        range: 300
                    }
                ];
                
                // æŠ€èƒ½
                this.skills = {
                    multishot: 0,
                    pierce: 0,
                    projectileSize: 0,
                    critChance: 0,
                    lifeSteal: 0,
                    aura: 0
                };
                
                // å…‰ç¯æ•ˆæœ
                this.auraTimer = 0;
            }
            
            update(deltaTime, keys, game) {
                // ç§»åŠ¨
                let dx = 0, dy = 0;
                
                // é”®ç›˜è¾“å…¥
                if (keys['w'] || keys['W'] || keys['ArrowUp']) dy -= 1;
                if (keys['s'] || keys['S'] || keys['ArrowDown']) dy += 1;
                if (keys['a'] || keys['A'] || keys['ArrowLeft']) dx -= 1;
                if (keys['d'] || keys['D'] || keys['ArrowRight']) dx += 1;
                
                // è§¦æ‘¸è¾“å…¥ï¼ˆç§»åŠ¨ç«¯æ‘‡æ†ï¼‰
                if (game.touchInput.active) {
                    dx = game.touchInput.x;
                    dy = game.touchInput.y;
                } else if (dx !== 0 && dy !== 0) {
                    // å½’ä¸€åŒ–å¯¹è§’çº¿ç§»åŠ¨ï¼ˆä»…é”®ç›˜ï¼‰
                    dx *= 0.707;
                    dy *= 0.707;
                }
                
                this.x += dx * this.moveSpeed * deltaTime;
                this.y += dy * this.moveSpeed * deltaTime;
                
                // é™åˆ¶åœ¨è¾¹ç•Œå†…
                this.x = Math.max(this.radius, Math.min(game.width - this.radius, this.x));
                this.y = Math.max(this.radius, Math.min(game.height - this.radius, this.y));
                
                // æ›´æ–°æ­¦å™¨
                this.weapons.forEach(weapon => {
                    weapon.cooldown -= deltaTime;
                    if (weapon.cooldown <= 0) {
                        this.attack(weapon, game);
                        weapon.cooldown = weapon.maxCooldown;
                    }
                });
                
                // æ›´æ–°å…‰ç¯æ•ˆæœ
                if (this.skills.aura > 0) {
                    this.auraTimer -= deltaTime;
                    if (this.auraTimer <= 0) {
                        this.auraTimer = 0.5; // æ¯0.5ç§’è§¦å‘ä¸€æ¬¡
                        
                        game.enemies.forEach(enemy => {
                            const dx = enemy.x - this.x;
                            const dy = enemy.y - this.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            
                            if (dist < 150 * this.skills.aura) {
                                enemy.takeDamage(this.damage * 0.5 * this.skills.aura);
                            }
                        });
                    }
                }
            }
            
            attack(weapon, game) {
                // æ‰¾åˆ°æœ€è¿‘çš„æ•Œäºº
                let nearest = null;
                let minDist = weapon.range || 300;
                
                game.enemies.forEach(enemy => {
                    const dx = enemy.x - this.x;
                    const dy = enemy.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < minDist) {
                        minDist = dist;
                        nearest = enemy;
                    }
                });
                
                if (nearest) {
                    const baseAngle = Math.atan2(nearest.y - this.y, nearest.x - this.x);
                    const projectileCount = weapon.projectileCount + this.skills.multishot;
                    
                    // è®¡ç®—ä¼¤å®³
                    let finalDamage = this.damage * weapon.level;
                    
                    // æš´å‡»åˆ¤æ–­
                    if (Math.random() < this.skills.critChance * 0.1) {
                        finalDamage *= 2;
                    }
                    
                    // å‘å°„å¤šä¸ªå¼¹è¯
                    for (let i = 0; i < projectileCount; i++) {
                        let angle = baseAngle;
                        
                        if (projectileCount > 1) {
                            const spread = Math.PI / 6; // 30åº¦æ‰©æ•£
                            angle += (i - (projectileCount - 1) / 2) * (spread / projectileCount);
                        }
                        
                        const size = 5 * (1 + this.skills.projectileSize * 0.3);
                        const pierce = this.skills.pierce;
                        
                        if (weapon.type === 'sword') {
                            game.projectiles.push(new Projectile(
                                this.x, this.y, angle, 
                                finalDamage, 
                                400, '#FFD700', size, pierce
                            ));
                        } else if (weapon.type === 'fireball') {
                            game.projectiles.push(new Projectile(
                                this.x, this.y, angle, 
                                finalDamage * 1.5, 
                                300, '#ff6600', size * 1.5, pierce, 'fireball'
                            ));
                        } else if (weapon.type === 'lightning') {
                            game.projectiles.push(new Projectile(
                                this.x, this.y, angle, 
                                finalDamage * 0.8, 
                                600, '#00ffff', size * 0.8, pierce + 2, 'lightning'
                            ));
                        } else if (weapon.type === 'holy') {
                            game.projectiles.push(new Projectile(
                                this.x, this.y, angle, 
                                finalDamage * 2, 
                                250, '#ffffff', size * 2, pierce, 'holy'
                            ));
                        }
                    }
                }
            }
            
            takeDamage(amount) {
                this.health -= amount;
                if (this.health < 0) this.health = 0;
            }
            
            heal(amount) {
                this.health = Math.min(this.maxHealth, this.health + amount);
            }
            
            addExp(amount) {
                this.exp += amount * this.expMultiplier;
                
                while (this.exp >= this.expToNextLevel) {
                    this.levelUp();
                }
            }
            
            levelUp() {
                this.exp -= this.expToNextLevel;
                this.level++;
                this.expToNextLevel = Math.floor(100 * Math.pow(1.2, this.level - 1));
                
                // æ˜¾ç¤ºå‡çº§èœå•
                game.showUpgradeMenu();
            }
            
            getAvailableUpgrades() {
                const upgrades = [
                    {
                        id: 'maxHealth',
                        name: 'ğŸ’— ç”Ÿå‘½å¼ºåŒ–',
                        description: 'æœ€å¤§ç”Ÿå‘½å€¼ +20',
                        currentLevel: 0,
                        apply: () => {
                            this.maxHealth += 20;
                            this.health += 20;
                        }
                    },
                    {
                        id: 'damage',
                        name: 'âš”ï¸ ä¼¤å®³æå‡',
                        description: 'ä¼¤å®³ +20%',
                        currentLevel: 0,
                        apply: () => {
                            this.damage *= 1.2;
                        }
                    },
                    {
                        id: 'attackSpeed',
                        name: 'âš¡ æ”»å‡»é€Ÿåº¦',
                        description: 'æ”»å‡»é€Ÿåº¦ +15%',
                        currentLevel: 0,
                        apply: () => {
                            this.attackSpeed *= 1.15;
                            this.weapons.forEach(w => w.maxCooldown /= 1.15);
                        }
                    },
                    {
                        id: 'moveSpeed',
                        name: 'ğŸƒ ç§»åŠ¨é€Ÿåº¦',
                        description: 'ç§»åŠ¨é€Ÿåº¦ +10%',
                        currentLevel: 0,
                        apply: () => {
                            this.moveSpeed *= 1.1;
                        }
                    },
                    {
                        id: 'multishot',
                        name: 'ğŸ¯ å¤šé‡å°„å‡»',
                        description: 'å‘å°„ +1 ä¸ªé¢å¤–å¼¹è¯',
                        currentLevel: this.skills.multishot,
                        apply: () => {
                            this.skills.multishot++;
                        }
                    },
                    {
                        id: 'projectileSize',
                        name: 'ğŸ“ å¼¹è¯å¢å¤§',
                        description: 'å¼¹è¯ä½“ç§¯å’ŒèŒƒå›´ +30%',
                        currentLevel: this.skills.projectileSize,
                        apply: () => {
                            this.skills.projectileSize++;
                        }
                    },
                    {
                        id: 'pierce',
                        name: 'ğŸ¯ ç©¿é€',
                        description: 'å¼¹è¯å¯ä»¥ç©¿é€ +1 ä¸ªæ•Œäºº',
                        currentLevel: this.skills.pierce,
                        apply: () => {
                            this.skills.pierce++;
                        }
                    },
                    {
                        id: 'critChance',
                        name: 'ğŸ’¥ æš´å‡»',
                        description: 'æš´å‡»å‡ ç‡ +10% (é€ æˆ2å€ä¼¤å®³)',
                        currentLevel: this.skills.critChance,
                        apply: () => {
                            this.skills.critChance++;
                        }
                    },
                    {
                        id: 'lifeSteal',
                        name: 'ğŸ©¸ ç”Ÿå‘½å·å–',
                        description: 'é€ æˆä¼¤å®³æ—¶æ¢å¤ +5% ç”Ÿå‘½',
                        currentLevel: this.skills.lifeSteal,
                        apply: () => {
                            this.skills.lifeSteal++;
                        }
                    },
                    {
                        id: 'aura',
                        name: 'ğŸŒŸ ç¥åœ£å…‰ç¯',
                        description: 'å‘¨å›´æ•ŒäººæŒç»­å—åˆ°ä¼¤å®³ï¼ŒèŒƒå›´å¢åŠ ',
                        currentLevel: this.skills.aura,
                        apply: () => {
                            this.skills.aura++;
                        }
                    }
                ];
                
                // æ·»åŠ æ–°æ­¦å™¨å‡çº§
                const weaponUpgrades = [
                    {
                        id: 'fireball',
                        name: 'ğŸ”¥ ç«çƒæœ¯',
                        description: 'è·å¾—ç«çƒæ­¦å™¨ï¼Œé€ æˆé«˜é¢ä¼¤å®³',
                        currentLevel: 0,
                        isWeapon: true,
                        apply: () => {
                            const existing = this.weapons.find(w => w.type === 'fireball');
                            if (existing) {
                                existing.level++;
                                existing.projectileCount++;
                            } else {
                                this.weapons.push({
                                    type: 'fireball',
                                    level: 1,
                                    cooldown: 0,
                                    maxCooldown: 1.5,
                                    projectileCount: 1,
                                    range: 350
                                });
                            }
                        }
                    },
                    {
                        id: 'lightning',
                        name: 'âš¡ é—ªç”µé“¾',
                        description: 'è·å¾—é—ªç”µæ­¦å™¨ï¼Œæ”»å‡»é€Ÿåº¦å¿«ï¼Œè‡ªå¸¦ç©¿é€',
                        currentLevel: 0,
                        isWeapon: true,
                        apply: () => {
                            const existing = this.weapons.find(w => w.type === 'lightning');
                            if (existing) {
                                existing.level++;
                                existing.maxCooldown *= 0.9;
                            } else {
                                this.weapons.push({
                                    type: 'lightning',
                                    level: 1,
                                    cooldown: 0,
                                    maxCooldown: 0.5,
                                    projectileCount: 1,
                                    range: 400
                                });
                            }
                        }
                    },
                    {
                        id: 'holy',
                        name: 'âœ¨ ç¥åœ£ä¹‹å…‰',
                        description: 'è·å¾—ç¥åœ£æ­¦å™¨ï¼Œä¼¤å®³æé«˜ä½†æ”»å‡»è¾ƒæ…¢',
                        currentLevel: 0,
                        isWeapon: true,
                        apply: () => {
                            const existing = this.weapons.find(w => w.type === 'holy');
                            if (existing) {
                                existing.level++;
                                existing.projectileCount++;
                            } else {
                                this.weapons.push({
                                    type: 'holy',
                                    level: 1,
                                    cooldown: 0,
                                    maxCooldown: 2,
                                    projectileCount: 1,
                                    range: 300
                                });
                            }
                        }
                    }
                ];
                
                // æ ¹æ®ç­‰çº§è§£é”æ­¦å™¨
                if (this.level >= 3) {
                    upgrades.push(...weaponUpgrades);
                }
                
                // å‡çº§å·²æœ‰æ­¦å™¨
                this.weapons.forEach(weapon => {
                    if (weapon.type !== 'sword' && weapon.level < 10) {
                        upgrades.push({
                            id: weapon.type + '_upgrade',
                            name: `â¬†ï¸ ${weapon.type === 'fireball' ? 'ç«çƒ' : weapon.type === 'lightning' ? 'é—ªç”µ' : 'ç¥åœ£'} å‡çº§`,
                            description: `æå‡æ­¦å™¨ç­‰çº§å’Œæ•ˆæœ`,
                            currentLevel: weapon.level,
                            apply: () => {
                                weapon.level++;
                                if (weapon.type === 'fireball') {
                                    weapon.projectileCount++;
                                } else if (weapon.type === 'lightning') {
                                    weapon.maxCooldown *= 0.9;
                                } else if (weapon.type === 'holy') {
                                    weapon.projectileCount++;
                                }
                            }
                        });
                    }
                });
                
                return upgrades;
            }
            
            applyUpgrade(upgrade) {
                upgrade.apply();
            }
            
            render(ctx) {
                // ç»˜åˆ¶å…‰ç¯æ•ˆæœ
                if (this.skills.aura > 0) {
                    const auraRadius = 150 * this.skills.aura;
                    const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, auraRadius);
                    gradient.addColorStop(0, 'rgba(255, 215, 0, 0.2)');
                    gradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, auraRadius, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // ç»˜åˆ¶é˜´å½±
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.arc(this.x + 3, this.y + 3, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // ç»˜åˆ¶ç©å®¶
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                
                // ç»˜åˆ¶è¾¹æ¡†
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // ç»˜åˆ¶çœ¼ç›
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(this.x - 7, this.y - 5, 3, 0, Math.PI * 2);
                ctx.arc(this.x + 7, this.y - 5, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // æ•Œäººç±»
        class Enemy {
            constructor(x, y, type, healthMultiplier = 1) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.animationTimer = 0;
                
                // æ ¹æ®ç±»å‹è®¾ç½®å±æ€§
                switch(type) {
                    case 'zombie':
                        this.radius = 15;
                        this.maxHealth = 30 * healthMultiplier;
                        this.speed = 80;
                        this.damage = 10;
                        this.color = '#00ff00';
                        this.expValue = 10;
                        this.coinValue = 1;
                        break;
                    case 'ghost':
                        this.radius = 12;
                        this.maxHealth = 20 * healthMultiplier;
                        this.speed = 120;
                        this.damage = 15;
                        this.color = '#9370DB';
                        this.expValue = 15;
                        this.coinValue = 2;
                        break;
                    case 'demon':
                        this.radius = 20;
                        this.maxHealth = 50 * healthMultiplier;
                        this.speed = 60;
                        this.damage = 20;
                        this.color = '#ff0000';
                        this.expValue = 25;
                        this.coinValue = 3;
                        break;
                    case 'elite':
                        this.radius = 25;
                        this.maxHealth = 100 * healthMultiplier;
                        this.speed = 70;
                        this.damage = 30;
                        this.color = '#ff6600';
                        this.expValue = 50;
                        this.coinValue = 8;
                        this.isElite = true;
                        break;
                    case 'boss':
                        this.radius = 40;
                        this.maxHealth = 500 * healthMultiplier;
                        this.speed = 50;
                        this.damage = 40;
                        this.color = '#8B00FF';
                        this.expValue = 200;
                        this.coinValue = 50;
                        this.isBoss = true;
                        break;
                }
                
                this.health = this.maxHealth;
            }
            
            update(deltaTime, player) {
                this.animationTimer += deltaTime;
                
                // è¿½è¸ªç©å®¶
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > 0) {
                    this.x += (dx / dist) * this.speed * deltaTime;
                    this.y += (dy / dist) * this.speed * deltaTime;
                }
            }
            
            takeDamage(amount) {
                this.health -= amount;
            }
            
            render(ctx) {
                ctx.save();
                
                // Boss ç‰¹æ•ˆ
                if (this.isBoss) {
                    // æ—‹è½¬å…‰ç¯
                    const rotation = this.animationTimer * 2;
                    const auraRadius = this.radius * 1.8;
                    
                    for (let i = 0; i < 6; i++) {
                        const angle = rotation + (i * Math.PI / 3);
                        const x = this.x + Math.cos(angle) * auraRadius;
                        const y = this.y + Math.sin(angle) * auraRadius;
                        
                        ctx.fillStyle = 'rgba(139, 0, 255, 0.3)';
                        ctx.beginPath();
                        ctx.arc(x, y, 8, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                // Elite ç‰¹æ•ˆ
                if (this.isElite) {
                    const pulseSize = this.radius * (1 + Math.sin(this.animationTimer * 5) * 0.2);
                    ctx.fillStyle = 'rgba(255, 102, 0, 0.2)';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, pulseSize * 1.3, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // ç»˜åˆ¶è¡€æ¡
                if (this.health < this.maxHealth) {
                    const barWidth = this.radius * 2.5;
                    const barHeight = this.isBoss ? 8 : this.isElite ? 6 : 4;
                    const barX = this.x - barWidth / 2;
                    const barY = this.y - this.radius - 15;
                    
                    // èƒŒæ™¯
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(barX - 2, barY - 2, barWidth + 4, barHeight + 4);
                    
                    // è¡€æ¡
                    const gradient = ctx.createLinearGradient(barX, barY, barX + barWidth, barY);
                    gradient.addColorStop(0, '#ff0000');
                    gradient.addColorStop(1, '#ff6600');
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(barX, barY, barWidth * (this.health / this.maxHealth), barHeight);
                    
                    // è¾¹æ¡†
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(barX, barY, barWidth, barHeight);
                }
                
                // ç»˜åˆ¶æ•Œäººä¸»ä½“
                const pulseAmount = this.isBoss ? Math.sin(this.animationTimer * 3) * 0.1 : 0;
                const currentRadius = this.radius * (1 + pulseAmount);
                
                // é˜´å½±
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.arc(this.x + 3, this.y + 3, currentRadius, 0, Math.PI * 2);
                ctx.fill();
                
                // å‘å…‰æ•ˆæœ
                if (this.isBoss || this.isElite) {
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = this.color;
                }
                
                // ä¸»ä½“
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, currentRadius, 0, Math.PI * 2);
                ctx.fill();
                
                // è¾¹æ¡†
                ctx.strokeStyle = this.isBoss ? '#FFD700' : this.isElite ? '#FFA500' : '#000';
                ctx.lineWidth = this.isBoss ? 4 : this.isElite ? 3 : 2;
                ctx.stroke();
                
                ctx.shadowBlur = 0;
                
                // Boss çœ¼ç›
                if (this.isBoss) {
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(this.x - 12, this.y - 8, 6, 0, Math.PI * 2);
                    ctx.arc(this.x + 12, this.y - 8, 6, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // çœ¼ç›é«˜å…‰
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(this.x - 10, this.y - 10, 3, 0, Math.PI * 2);
                    ctx.arc(this.x + 14, this.y - 10, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }

        // å¼¹è¯ç±»
        class Projectile {
            constructor(x, y, angle, damage, speed, color, radius, pierce = 0, type = 'normal') {
                this.x = x;
                this.y = y;
                this.angle = angle;
                this.damage = damage;
                this.speed = speed;
                this.color = color;
                this.radius = radius;
                this.lifetime = 3;
                this.pierce = pierce;
                this.pierced = 0;
                this.type = type;
                
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                
                // ç‰¹æ•ˆè®¡æ—¶å™¨
                this.effectTimer = 0;
            }
            
            update(deltaTime) {
                this.x += this.vx * deltaTime;
                this.y += this.vy * deltaTime;
                this.lifetime -= deltaTime;
                this.effectTimer += deltaTime;
            }
            
            render(ctx) {
                ctx.save();
                
                // æ ¹æ®ç±»å‹ç»˜åˆ¶ä¸åŒæ•ˆæœ
                if (this.type === 'fireball') {
                    // ç«çƒæ‹–å°¾æ•ˆæœ
                    const trailLength = 3;
                    for (let i = 0; i < trailLength; i++) {
                        const alpha = 1 - (i / trailLength);
                        const offset = i * 10;
                        const tx = this.x - Math.cos(this.angle) * offset;
                        const ty = this.y - Math.sin(this.angle) * offset;
                        
                        ctx.globalAlpha = alpha * 0.5;
                        ctx.fillStyle = this.color;
                        ctx.beginPath();
                        ctx.arc(tx, ty, this.radius * (1 - i * 0.2), 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.globalAlpha = 1;
                } else if (this.type === 'lightning') {
                    // é—ªç”µæ•ˆæœ
                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = this.radius;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = this.color;
                    
                    const segments = 5;
                    const segmentLength = 20;
                    
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    
                    for (let i = 0; i < segments; i++) {
                        const offsetX = (Math.random() - 0.5) * 10;
                        const offsetY = (Math.random() - 0.5) * 10;
                        const px = this.x + Math.cos(this.angle) * segmentLength * i + offsetX;
                        const py = this.y + Math.sin(this.angle) * segmentLength * i + offsetY;
                        ctx.lineTo(px, py);
                    }
                    
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                } else if (this.type === 'holy') {
                    // ç¥åœ£å…‰è¾‰æ•ˆæœ
                    const pulseSize = this.radius * (1 + Math.sin(this.effectTimer * 10) * 0.3);
                    
                    // å¤–åœˆå…‰æ™•
                    const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, pulseSize * 2);
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                    gradient.addColorStop(0.5, 'rgba(255, 215, 0, 0.4)');
                    gradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, pulseSize * 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // åå­—å…‰èŠ’
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.lineWidth = 3;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#ffffff';
                    
                    const crossSize = pulseSize * 1.5;
                    ctx.beginPath();
                    ctx.moveTo(this.x - crossSize, this.y);
                    ctx.lineTo(this.x + crossSize, this.y);
                    ctx.moveTo(this.x, this.y - crossSize);
                    ctx.lineTo(this.x, this.y + crossSize);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }
                
                // æ ¸å¿ƒå¼¹è¯
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 15;
                ctx.shadowColor = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                
                ctx.restore();
            }
            
            canPierce() {
                return this.pierced < this.pierce;
            }
            
            onPierce() {
                this.pierced++;
            }
        }

        // ç²’å­ç±»
        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.radius = Math.random() * 3 + 2;
                this.lifetime = 0.5;
                
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 100 + 50;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
            }
            
            update(deltaTime) {
                this.x += this.vx * deltaTime;
                this.y += this.vy * deltaTime;
                this.vx *= 0.95;
                this.vy *= 0.95;
                this.lifetime -= deltaTime;
            }
            
            render(ctx) {
                ctx.globalAlpha = this.lifetime / 0.5;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        // æ‰è½ç‰©ç±»
        class Pickup {
            constructor(x, y, type, value) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.value = value;
                this.lifetime = 10;
                this.radius = 8;
                
                switch(type) {
                    case 'exp':
                        this.color = '#00ff00';
                        break;
                    case 'coin':
                        this.color = '#FFD700';
                        break;
                    case 'health':
                        this.color = '#ff0000';
                        break;
                }
            }
            
            update(deltaTime, player) {
                this.lifetime -= deltaTime;
                
                // å¸å¼•å‘ç©å®¶
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < 100) {
                    const attractSpeed = 200;
                    this.x += (dx / dist) * attractSpeed * deltaTime;
                    this.y += (dy / dist) * attractSpeed * deltaTime;
                }
            }
            
            render(ctx) {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        // ä¼¤å®³æ•°å­—ç±»
        class DamageNumber {
            constructor(x, y, damage) {
                this.x = x;
                this.y = y;
                this.damage = damage;
                this.lifetime = 1;
                this.vy = -100; // å‘ä¸Šé£˜
                this.opacity = 1;
            }
            
            update(deltaTime) {
                this.y += this.vy * deltaTime;
                this.lifetime -= deltaTime;
                this.opacity = this.lifetime;
            }
            
            render(ctx) {
                ctx.save();
                ctx.globalAlpha = this.opacity;
                ctx.fillStyle = '#ffff00';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.strokeText(this.damage.toString(), this.x, this.y);
                ctx.fillText(this.damage.toString(), this.x, this.y);
                ctx.restore();
            }
        }

        // åˆå§‹åŒ–æ¸¸æˆ
        const game = new Game();
        game.showMainMenu();
    </script>
</body>
</html>
